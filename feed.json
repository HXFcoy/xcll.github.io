{
    "version": "https://jsonfeed.org/version/1",
    "title": "xcll’s blog",
    "description": "",
    "home_page_url": "https://hxfcoy.github.io/xcll.github.io",
    "feed_url": "https://hxfcoy.github.io/xcll.github.io/feed.json",
    "user_comment": "",
    "icon": "https://hxfcoy.github.io/xcll.github.io/media/website/image-removebg-preview.png",
    "author": {
        "name": "fcoy"
    },
    "items": [
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/2144-da-zhe-gou-mai-tang-guo-de-zui-xiao-kai-xiao.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/2144-da-zhe-gou-mai-tang-guo-de-zui-xiao-kai-xiao.html",
            "title": "2144. 打折购买糖果的最小开销",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i5p1e3qur\">题目</a></li>\n<li><a href=\"#mcetoc_1i5p1e3qus\">代码</a></li>\n<li><a href=\"#mcetoc_1i5p1e3qut\">解释</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i5p1e3qur\">题目</h3>\n<p>一家商店正在打折销售糖果。每购买 <strong>两个</strong> 糖果，商店会 <strong>免费</strong> 送一个糖果。</p>\n<p>免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 <strong>较小值</strong> 。</p>\n<ul>\n<li>比方说，总共有 <code>4</code> 个糖果，价格分别为 <code>1</code> ，<code>2</code> ，<code>3</code> 和 <code>4</code> ，一位顾客买了价格为 <code>2</code> 和 <code>3</code> 的糖果，那么他可以免费获得价格为 <code>1</code> 的糖果，但不能获得价格为 <code>4</code> 的糖果。</li>\n</ul>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 表示第 <code>i</code> 个糖果的价格，请你返回获得 <strong>所有</strong> 糖果的 <strong>最小</strong> 总开销。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>cost = [1,2,3]\n<strong>输出：</strong>5\n<strong>解释：</strong>我们购买价格为 2 和 3 的糖果，然后免费获得价格为 1 的糖果。\n总开销为 2 + 3 = 5 。这是开销最小的 <strong>唯一</strong> 方案。\n注意，我们不能购买价格为 1 和 3 的糖果，并免费获得价格为 2 的糖果。\n这是因为免费糖果的价格必须小于等于购买的 2 个糖果价格的较小值。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>cost = [6,5,7,9,2,2]\n<strong>输出：</strong>23\n<strong>解释：</strong>最小总开销购买糖果方案为：\n- 购买价格为 9 和 7 的糖果\n- 免费获得价格为 6 的糖果\n- 购买价格为 5 和 2 的糖果\n- 免费获得价格为 2 的最后一个糖果\n因此，最小总开销为 9 + 7 + 5 + 2 = 23 。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>cost = [5,5]\n<strong>输出：</strong>10\n<strong>解释：</strong>由于只有 2 个糖果，我们需要将它们都购买，而且没有免费糖果。\n所以总最小开销为 5 + 5 = 10 。</pre>\n<h3 id=\"mcetoc_1i5p1e3qus\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>// 比较函数，用于qsort排序\nint compare(const void* a, const void* b) {\n    return *(int*)b - *(int*)a; // 从大到小排序\n}\n\nint minimumCost(int* cost, int costSize) {\n    // 按价格从大到小排序\n    qsort(cost, costSize, sizeof(int), compare);\n    \n    int totalCost = 0;\n    \n    // 遍历所有糖果，每次取3个\n    for (int i = 0; i &lt; costSize; i++) {\n        // 只累加前两个糖果的价格，第三个糖果免费\n        if (i % 3 != 2) {\n            totalCost += cost[i];\n        }\n    }\n    \n    return totalCost;\n}</code></pre>\n<h3 id=\"mcetoc_1i5p1e3qut\">解释</h3>\n<ol>\n<li><strong>排序</strong>：<code>qsort</code>函数将糖果价格从高到低排序。</li>\n<li><strong>遍历</strong>：在循环中，通过 <code>i % 3 != 2</code> 来判断是否是每组中的第三个糖果，若是，则跳过它（因为它是免费的）。</li>\n<li><strong>累加价格</strong>：每组前两个糖果的价格累加到 <code>totalCost</code> 中。</li>\n</ol>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-21T07:20:03+08:00",
            "date_modified": "2024-08-21T07:20:03+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/989-shu-zu-xing-shi-de-zheng-shu-jia-fa.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/989-shu-zu-xing-shi-de-zheng-shu-jia-fa.html",
            "title": "989. 数组形式的整数加法",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i5mfanpl15\">题目</a></li>\n<li><a href=\"#mcetoc_1i5mfanpl16\">代码</a></li>\n<li><a href=\"#mcetoc_1i5mfanpl17\">解释</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i5mfanpl15\">题目</h3>\n<p>整数的 <strong>数组形式</strong>  <code>num</code> 是按照从左到右的顺序表示其数字的数组。</p>\n<ul>\n<li>例如，对于 <code>num = 1321</code> ，数组形式是 <code>[1,3,2,1]</code> 。</li>\n</ul>\n<p>给定 <code>num</code> ，整数的 <strong>数组形式</strong> ，和整数 <code>k</code> ，返回 <em>整数 <code>num + k</code> 的 <strong>数组形式</strong></em> 。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>num = [1,2,0,0], k = 34\n<strong>输出：</strong>[1,2,3,4]\n<strong>解释：</strong>1200 + 34 = 1234\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>num = [2,7,4], k = 181\n<strong>输出：</strong>[4,5,5]\n<strong>解释：</strong>274 + 181 = 455\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>num = [2,1,5], k = 806\n<strong>输出：</strong>[1,0,2,1]\n<strong>解释：</strong>215 + 806 = 1021</pre>\n<h3 id=\"mcetoc_1i5mfanpl16\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>int* addToArrayForm(int* num, int numSize, int k, int* returnSize) {\n    // 分配足够大的空间存储结果数组\n    int* result = (int*)malloc(sizeof(int) * (numSize + 10)); // 预留足够的空间处理进位\n    int currentIndex = 0; // 用于存放结果数组的当前索引\n    int carry = k; // 初始进位为 k\n    int i;\n\n    // 从 num 数组的末尾向前遍历\n    for (i = numSize - 1; i &gt;= 0 || carry &gt; 0; i--) {\n        if (i &gt;= 0) {\n            carry += num[i]; // 将当前位的数字与进位相加\n        }\n        result[currentIndex++] = carry % 10; // 取个位作为当前结果位\n        carry /= 10; // 更新进位\n    }\n\n    // 结果数组是逆序存储的，需要翻转\n    for (i = 0; i &lt; currentIndex / 2; i++) {\n        int temp = result[i];\n        result[i] = result[currentIndex - i - 1];\n        result[currentIndex - i - 1] = temp;\n    }\n\n    *returnSize = currentIndex; // 更新结果数组的大小\n    return result; // 返回结果数组的指针\n}</code></pre>\n<h3 id=\"mcetoc_1i5mfanpl17\">解释</h3>\n<ul>\n<li>\n<p><strong>分配足够大的空间</strong>：由于进位的原因，结果数组可能比 <code>num</code> 长，因此分配 <code>numSize + 10</code> 的空间来容纳可能的额外位数。</p>\n</li>\n<li>\n<p><strong>逐位相加</strong>：从 <code>num</code> 的最低位（数组末尾）开始，逐位将 <code>num</code> 的对应位与 <code>k</code> 的当前位相加，并处理进位。</p>\n</li>\n<li>\n<p><strong>处理剩余的进位</strong>：在 <code>num</code> 数组遍历完后，如果还有进位，继续将进位加到结果中。</p>\n</li>\n<li>\n<p><strong>翻转结果</strong>：由于结果是从最低位开始存储的，因此最后需要翻转数组才能得到正确的顺序。</p>\n</li>\n<li>\n<p><strong>返回结果</strong>：返回计算得到的结果数组以及其大小。</p>\n</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-20T07:25:10+08:00",
            "date_modified": "2024-08-20T07:25:10+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/mian-shi-ti-1710-zhu-yao-yuan-su.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/mian-shi-ti-1710-zhu-yao-yuan-su.html",
            "title": "面试题 17.10. 主要元素",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i5jsiu2c11\">题目</a></li>\n<li><a href=\"#mcetoc_1i5jsiu2c12\">代码</a></li>\n<li><a href=\"#mcetoc_1i5jsiu2c13\">Boyer-Moore 投票算法的详细解释</a>\n<ul>\n<li><a href=\"#mcetoc_1i5jsiu2c14\">问题定义</a></li>\n<li><a href=\"#mcetoc_1i5jsiu2c15\">算法思想</a></li>\n<li><a href=\"#mcetoc_1i5jsiu2c16\">具体步骤</a></li>\n<li><a href=\"#mcetoc_1i5jsiu2c17\">为什么这个算法有效？</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i5jsiu2c11\">题目</h3>\n<p>数组中占比超过一半的元素称之为主要元素。给你一个<strong> 整数 </strong>数组，找出其中的主要元素。若没有，返回 <code>-1</code> 。请设计时间复杂度为 <code>O(N)</code> 、空间复杂度为 <code>O(1)</code> 的解决方案。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>[1,2,5,9,5,9,5,5,5]\n<strong>输出：</strong>5</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>[3,2]\n<strong>输出：</strong>-1</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>[2,2,1,1,1,2,2]\n<strong>输出：</strong>2</pre>\n<h3 id=\"mcetoc_1i5jsiu2c12\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>int majorityElement(int* nums, int numsSize) {\n    int candidate = 0;\n    int count = 0;\n    \n    // 第一遍遍历，找到候选人\n    for (int i = 0; i &lt; numsSize; i++) {\n        if (count == 0) {\n            candidate = nums[i];\n            count = 1;\n        } else if (nums[i] == candidate) {\n            count++;\n        } else {\n            count--;\n        }\n    }\n    \n    // 第二遍遍历，验证候选人是否为主要元素\n    count = 0;\n    for (int i = 0; i &lt; numsSize; i++) {\n        if (nums[i] == candidate) {\n            count++;\n        }\n    }\n    \n    // 判断是否是主要元素\n    if (count &gt; numsSize / 2) {\n        return candidate;\n    } else {\n        return -1;\n    }\n}\n</code></pre>\n<h3 id=\"mcetoc_1i5jsiu2c13\">Boyer-Moore 投票算法的详细解释</h3>\n<p>Boyer-Moore 投票算法是一种非常巧妙且高效的算法，用于在时间复杂度为 O(N) 且空间复杂度为 O(1) 的条件下找到数组中的主要元素。下面我们详细解释这个算法的工作原理和步骤。</p>\n<h4 id=\"mcetoc_1i5jsiu2c14\">问题定义</h4>\n<p>主要元素是指在数组中出现次数超过一半的元素。给定一个大小为 <code>n</code> 的数组，主要元素出现的次数必须超过 <code>n/2</code>。</p>\n<h4 id=\"mcetoc_1i5jsiu2c15\">算法思想</h4>\n<p>算法的核心思想是：</p>\n<ol>\n<li><strong>候选人筛选</strong>：我们需要找到一个“候选人”作为主要元素。通过一次遍历，我们可以确定一个候选人，这个候选人有可能是主要元素。</li>\n<li><strong>验证候选人</strong>：由于筛选出来的候选人不一定是主要元素，我们需要通过第二次遍历来验证这个候选人是否真的出现次数超过数组的一半。</li>\n</ol>\n<h4 id=\"mcetoc_1i5jsiu2c16\">具体步骤</h4>\n<p><strong>第一步：候选人筛选</strong></p>\n<ol>\n<li>\n<p>初始化两个变量：</p>\n<ul>\n<li><code>candidate</code>：用于记录当前的候选元素。</li>\n<li><code>count</code>：用于记录当前候选元素的出现次数。</li>\n</ul>\n</li>\n<li>\n<p>遍历整个数组：</p>\n<ul>\n<li>如果 <code>count</code> 为 <code>0</code>，表示当前没有候选人或前一个候选人已经被“淘汰”。此时将当前元素设置为新的候选人，并将 <code>count</code> 设为 <code>1</code>。</li>\n<li>如果当前元素与 <code>candidate</code> 相同，则说明这个元素支持当前的候选人，增加 <code>count</code>。</li>\n<li>如果当前元素与 <code>candidate</code> 不同，则认为这是一个反对票，减少 <code>count</code>。</li>\n</ul>\n</li>\n</ol>\n<p>通过上述遍历，我们可以找到一个最终的候选人 <code>candidate</code>。这个候选人有可能是主要元素，但我们还需要验证。</p>\n<p><strong>第二步：验证候选人</strong></p>\n<ol>\n<li>初始化 <code>count</code> 为 <code>0</code>，然后再遍历数组。</li>\n<li>每遇到一个与 <code>candidate</code> 相同的元素，就增加 <code>count</code>。</li>\n<li>最后检查 <code>count</code> 是否大于 <code>n/2</code>：\n<ul>\n<li>如果是，说明 <code>candidate</code> 是主要元素，返回它。</li>\n<li>如果不是，说明数组中没有主要元素，返回 <code>-1</code>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"mcetoc_1i5jsiu2c17\">为什么这个算法有效？</h4>\n<p>要理解为什么这个算法有效，我们可以从以下角度来分析：</p>\n<ul>\n<li>\n<p><strong>筛选过程的有效性</strong>：当 <code>count</code> 变为 <code>0</code> 时，表示我们目前没有候选人或之前的候选人已经被完全抵消（即遇到了足够多的不同元素来平衡掉候选人）。此时，我们选择当前的元素作为新的候选人。由于主要元素的数量超过总数的一半，它不可能被完全抵消，因此最终得到的候选人要么是主要元素，要么是非主要元素。</p>\n</li>\n<li>\n<p><strong>验证过程的必要性</strong>：由于第一次筛选过程仅能保证筛选出一个潜在的候选人，因此我们需要第二次遍历来确认它是否真的出现次数超过一半。如果 <code>count</code> 大于 <code>n/2</code>，则它就是主要元素。</p>\n</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-19T07:19:08+08:00",
            "date_modified": "2024-08-19T07:19:08+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/1252-qi-shu-zhi-dan-yuan-ge-de-shu-mu.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/1252-qi-shu-zhi-dan-yuan-ge-de-shu-mu.html",
            "title": "1252. 奇数值单元格的数目",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i5hcdbnu1h\">题目</a></li>\n<li><a href=\"#mcetoc_1i5hcdbnu1i\">代码</a></li>\n<li><a href=\"#mcetoc_1i5hcdbnu1j\">代码说明</a></li>\n<li><a href=\"#mcetoc_1i5hcdbnu1k\">参数说明</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i5hcdbnu1h\">题目</h3>\n<p>给你一个 <code>m x n</code> 的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p>\n<p>另有一个二维索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 指向矩阵中的某个位置，其中 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（<strong>从 <code>0</code> 开始编号</strong>）。</p>\n<p>对 <code>indices[i]</code> 所指向的每个位置，应同时执行下述增量操作：</p>\n<ol>\n<li><code>r<sub>i</sub></code> 行上的所有单元格，加 <code>1</code> 。</li>\n<li><code>c<sub>i</sub></code> 列上的所有单元格，加 <code>1</code> 。</li>\n</ol>\n<p>给你 <code>m</code>、<code>n</code> 和 <code>indices</code> 。请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 <strong>奇数值单元格</strong> 的数目。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<p><img loading=\"lazy\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png\" alt=\"\" data-is-external-image=\"true\"></p>\n<pre><strong>输入：</strong>m = 2, n = 3, indices = [[0,1],[1,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>最开始的矩阵是 [[0,0,0],[0,0,0]]。\n第一次增量操作后得到 [[1,2,1],[0,1,0]]。\n最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。\n</pre>\n<p><strong>示例 2：</strong></p>\n<p><img loading=\"lazy\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png\" alt=\"\" data-is-external-image=\"true\"></p>\n<pre><strong>输入：</strong>m = 2, n = 2, indices = [[1,1],[0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。</pre>\n<h3 id=\"mcetoc_1i5hcdbnu1i\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize) {\n    // 初始化行和列的增量计数\n    int* row_count = (int*)calloc(m, sizeof(int));\n    int* col_count = (int*)calloc(n, sizeof(int));\n    \n    // 对每个 indices 中的 (ri, ci) 进行操作\n    for (int i = 0; i &lt; indicesSize; i++) {\n        int ri = indices[i][0];\n        int ci = indices[i][1];\n        row_count[ri]++;\n        col_count[ci]++;\n    }\n    \n    // 计算奇数值单元格的数量\n    int odd_count = 0;\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            // 计算当前单元格的值\n            int value = row_count[i] + col_count[j];\n            if (value % 2 == 1) {\n                odd_count++;\n            }\n        }\n    }\n    \n    // 释放动态分配的内存\n    free(row_count);\n    free(col_count);\n    \n    return odd_count;\n}</code></pre>\n<h3 id=\"mcetoc_1i5hcdbnu1j\">代码说明</h3>\n<ol>\n<li><strong>内存分配</strong>：使用 <code>calloc</code> 分别为 <code>row_count</code> 和 <code>col_count</code> 动态分配内存，并将其初始值设置为 0。</li>\n<li><strong>操作增量</strong>：对每个索引 <code>[ri, ci]</code>，增加对应行和列的计数。</li>\n<li><strong>计算奇数单元格</strong>：通过遍历每个单元格，计算其对应的行列增量和，如果结果是奇数，增加计数。</li>\n<li><strong>释放内存</strong>：最后使用 <code>free</code> 释放动态分配的内存。</li>\n</ol>\n<h3 id=\"mcetoc_1i5hcdbnu1k\">参数说明</h3>\n<ul>\n<li><code>m</code>：矩阵的行数。</li>\n<li><code>n</code>：矩阵的列数。</li>\n<li><code>indices</code>：二维索引数组。</li>\n<li><code>indicesSize</code>：<code>indices</code> 数组的行数（即索引对的数量）。</li>\n<li><code>indicesColSize</code>：每一行索引数组的列数（始终为 2）。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-18T07:57:58+08:00",
            "date_modified": "2024-08-18T07:57:58+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/819-zui-chang-jian-de-dan-ci.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/819-zui-chang-jian-de-dan-ci.html",
            "title": "819. 最常见的单词",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i5eoag1i11\">题目</a></li>\n<li><a href=\"#mcetoc_1i5eoag1i12\">代码</a></li>\n<li><a href=\"#mcetoc_1i5eoag1i13\">解释</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i5eoag1i11\">题目</h3>\n<p>给你一个字符串 <code>paragraph</code> 和一个表示禁用词的字符串数组 <code>banned</code> ，返回出现频率最高的非禁用词。题目数据 <strong>保证 </strong>至少存在一个非禁用词，且答案<strong> 唯一 </strong>。</p>\n<p><code>paragraph</code> 中的单词 <strong>不区分大小写</strong> ，答案应以 <strong>小写 </strong>形式返回。</p>\n<p> </p>\n<p><strong class=\"example\">示例 1：</strong></p>\n<pre><strong>输入：</strong>paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\n<strong>输出：</strong>\"ball\"\n<strong>解释：</strong>\n\"hit\" 出现了 3 次，但它是禁用词。\n\"ball\" 出现了两次（没有其他单词出现这么多次），因此它是段落中出现频率最高的非禁用词。\n请注意，段落中的单词不区分大小写，\n标点符号会被忽略（即使它们紧挨着单词，如 \"ball,\"），\n并且尽管 \"hit\" 出现的次数更多，但它不能作为答案，因为它是禁用词。\n</pre>\n<p><strong class=\"example\">示例 2：</strong></p>\n<pre><strong>输入：</strong>paragraph = \"a.\", banned = []\n<strong>输出：</strong>\"a\"</pre>\n<h3 id=\"mcetoc_1i5eoag1i12\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>#define MAX_WORD_LEN 100\n#define MAX_PARA_LEN 10000\n\n// 函数用于比较哈希表中存储的单词\ntypedef struct {\n    char word[MAX_WORD_LEN];\n    int count;\n} HashTableEntry;\n\n// 将字符串转换为小写\nvoid toLowerCase(char* str) {\n    while (*str) {\n        *str = tolower(*str);\n        str++;\n    }\n}\n\n// 检查单词是否在禁用词列表中\nint isBanned(char* word, char** banned, int bannedSize) {\n    for (int i = 0; i &lt; bannedSize; i++) {\n        if (strcmp(word, banned[i]) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n// 从段落中提取下一个单词\nchar* nextWord(char* paragraph, int* index) {\n    static char word[MAX_WORD_LEN];\n    int i = 0;\n\n    while (paragraph[*index]) {\n        char c = paragraph[*index];\n        if (isalpha(c)) {\n            word[i++] = tolower(c);\n        } else if (i &gt; 0) {\n            break;\n        }\n        (*index)++;\n    }\n\n    word[i] = '\\0';\n    while (paragraph[*index] &amp;&amp; !isalpha(paragraph[*index])) {\n        (*index)++;\n    }\n\n    return word[0] ? word : NULL;\n}\n\nchar* mostCommonWord(char* paragraph, char** banned, int bannedSize) {\n    HashTableEntry hashTable[MAX_PARA_LEN] = {0};\n    int index = 0;\n    int maxCount = 0;\n    char* mostCommon = NULL;\n\n    while (paragraph[index]) {\n        char* word = nextWord(paragraph, &amp;index);\n        if (!word || isBanned(word, banned, bannedSize)) {\n            continue;\n        }\n\n        int found = 0;\n        for (int i = 0; i &lt; MAX_PARA_LEN &amp;&amp; hashTable[i].word[0]; i++) {\n            if (strcmp(hashTable[i].word, word) == 0) {\n                hashTable[i].count++;\n                found = 1;\n                if (hashTable[i].count &gt; maxCount) {\n                    maxCount = hashTable[i].count;\n                    mostCommon = hashTable[i].word;\n                }\n                break;\n            }\n        }\n\n        if (!found) {\n            for (int i = 0; i &lt; MAX_PARA_LEN; i++) {\n                if (hashTable[i].word[0] == '\\0') {\n                    strcpy(hashTable[i].word, word);\n                    hashTable[i].count = 1;\n                    if (hashTable[i].count &gt; maxCount) {\n                        maxCount = 1;\n                        mostCommon = hashTable[i].word;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return mostCommon;\n}</code></pre>\n<h3 id=\"mcetoc_1i5eoag1i13\">解释</h3>\n<ol>\n<li><strong>字符串转换为小写</strong>：在处理段落时，所有单词都会被转换为小写，以确保比较时不区分大小写。</li>\n<li><strong>提取单词</strong>：使用 <code>nextWord</code> 函数从段落中依次提取单词，并跳过标点符号和空格。</li>\n<li><strong>检查禁用词</strong>：每个提取的单词都会与禁用词列表进行比较，如果是禁用词则跳过。</li>\n<li><strong>计数与哈希表</strong>：通过哈希表存储每个单词及其出现次数，并更新频率最高的非禁用词。</li>\n<li><strong>返回结果</strong>：最终返回频率最高的非禁用词。</li>\n</ol>\n<p> </p>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-17T07:28:34+08:00",
            "date_modified": "2024-08-17T07:28:34+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/1295-tong-ji-wei-shu-wei-ou-shu-de-shu-zi.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/1295-tong-ji-wei-shu-wei-ou-shu-de-shu-zi.html",
            "title": "1295. 统计位数为偶数的数字",
            "content_html": "<h3>题目</h3>\n<p>给你一个整数数组 <code>nums</code>，请你返回其中位数为 <strong>偶数</strong> 的数字的个数。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [12,345,2,6,7896]\n<strong>输出：</strong>2\n<strong>解释：\n</strong>12 是 2 位数字（位数为偶数） \n345 是 3 位数字（位数为奇数）  \n2 是 1 位数字（位数为奇数） \n6 是 1 位数字 位数为奇数） \n7896 是 4 位数字（位数为偶数）  \n因此只有 12 和 7896 是位数为偶数的数字\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [555,901,482,1771]\n<strong>输出：</strong>1 \n<strong>解释： </strong>\n只有 1771 是位数为偶数的数字。</pre>\n<h3>代码</h3>\n<pre class=\"language-c line-numbers\"><code>int findNumbers(int* nums, int numsSize) {\n    int count = 0;\n    for (int i = 0; i &lt; numsSize; i++) {\n        int k = 0;\n        for (int j = nums[i]; j != 0; k++) {\n            j = j / 10;\n        }\n        if (k % 2 == 0) {\n            count++;\n        }\n    }\n    return count;\n}</code></pre>\n<p> </p>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-16T07:54:58+08:00",
            "date_modified": "2024-08-16T07:54:58+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/2525-gen-ju-gui-ze-jiang-xiang-zi-fen-lei.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/2525-gen-ju-gui-ze-jiang-xiang-zi-fen-lei.html",
            "title": "2525. 根据规则将箱子分类",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i59kcaatr\">题目</a></li>\n<li><a href=\"#mcetoc_1i59kcaats\">代码</a></li>\n<li><a href=\"#mcetoc_1i59kcaatt\">解释</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i59kcaatr\">题目</h3>\n<p>给你四个整数 <code>length</code> ，<code>width</code> ，<code>height</code> 和 <code>mass</code> ，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 <strong>类别</strong> 的字符串。</p>\n<ul>\n<li>如果满足以下条件，那么箱子是 <code>\"Bulky\"</code> 的：\n<ul>\n<li>箱子 <strong>至少有一个</strong> 维度大于等于 <code>10<sup>4</sup></code> 。</li>\n<li>或者箱子的 <strong>体积</strong> 大于等于 <code>10<sup>9</sup></code> 。</li>\n</ul>\n</li>\n<li>如果箱子的质量大于等于 <code>100</code> ，那么箱子是 <code>\"Heavy\"</code> 的。</li>\n<li>如果箱子同时是 <code>\"Bulky\"</code> 和 <code>\"Heavy\"</code> ，那么返回类别为 <code>\"Both\"</code> 。</li>\n<li>如果箱子既不是 <code>\"Bulky\"</code> ，也不是 <code>\"Heavy\"</code> ，那么返回类别为 <code>\"Neither\"</code> 。</li>\n<li>如果箱子是 <code>\"Bulky\"</code> 但不是 <code>\"Heavy\"</code> ，那么返回类别为 <code>\"Bulky\"</code> 。</li>\n<li>如果箱子是 <code>\"Heavy\"</code> 但不是 <code>\"Bulky\"</code> ，那么返回类别为 <code>\"Heavy\"</code> 。</li>\n</ul>\n<p><strong>注意</strong>，箱子的体积等于箱子的长度、宽度和高度的乘积。</p>\n<h3 id=\"mcetoc_1i59kcaats\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>char* categorizeBox(int length, int width, int height, int mass) {\n    long long volume = (long long)length * width * height;\n    int isBulky = length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000 || volume &gt;= 1000000000;\n    int isHeavy = mass &gt;= 100;\n\n    if (isBulky &amp;&amp; isHeavy) {\n        return \"Both\";\n    } else if (isBulky) {\n        return \"Bulky\";\n    } else if (isHeavy) {\n        return \"Heavy\";\n    } else {\n        return \"Neither\";\n    }\n}</code></pre>\n<h3 id=\"mcetoc_1i59kcaatt\">解释</h3>\n<ol>\n<li>计算体积 <code>volume</code>。</li>\n<li>检查是否为“Bulky”：如果任一维度大于等于 10,000 或者体积大于等于 10^9，则标记为 Bulky。</li>\n<li>检查是否为“Heavy”：如果质量大于等于 100，则标记为 Heavy。</li>\n<li>根据条件返回相应的类别：<code>Both</code>、<code>Bulky</code>、<code>Heavy</code> 或 <code>Neither</code>。</li>\n</ol>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-15T07:43:20+08:00",
            "date_modified": "2024-08-15T07:43:20+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/1880-jian-cha-mou-dan-ci-shi-fou-deng-yu-liang-dan-ci-zhi-he.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/1880-jian-cha-mou-dan-ci-shi-fou-deng-yu-liang-dan-ci-zhi-he.html",
            "title": "1880. 检查某单词是否等于两单词之和",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i572omh714\">题目</a></li>\n<li><a href=\"#mcetoc_1i572omh715\">代码</a></li>\n<li><a href=\"#mcetoc_1i572omh716\">解释</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i572omh714\">题目</h3>\n<p>字母的 <strong>字母值</strong> 取决于字母在字母表中的位置，<strong>从 0 开始</strong> 计数。即，<code>'a' -&gt; 0</code>、<code>'b' -&gt; 1</code>、<code>'c' -&gt; 2</code>，以此类推。</p>\n<p>对某个由小写字母组成的字符串 <code>s</code> 而言，其 <strong>数值</strong> 就等于将 <code>s</code> 中每个字母的 <strong>字母值</strong> 按顺序 <strong>连接</strong> 并 <strong>转换</strong> 成对应整数。</p>\n<ul>\n<li>例如，<code>s = \"acb\"</code> ，依次连接每个字母的字母值可以得到 <code>\"021\"</code> ，转换为整数得到 <code>21</code> 。</li>\n</ul>\n<p>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成。</p>\n<p>如果 <code>firstWord</code><em> </em>和<em> </em><code>secondWord</code> 的 <strong>数值之和</strong> 等于<em> </em><code>targetWord</code><em> </em>的数值，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"acb\" -&gt; \"021\" -&gt; 21\nsecondWord 的数值为 \"cba\" -&gt; \"210\" -&gt; 210\ntargetWord 的数值为 \"cdb\" -&gt; \"231\" -&gt; 231\n由于 21 + 210 == 231 ，返回 true\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aab\" -&gt; \"001\" -&gt; 1\n由于 0 + 0 != 1 ，返回 false</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aaaa\" -&gt; \"0000\" -&gt; 0\n由于 0 + 0 == 0 ，返回 true</pre>\n<h3 id=\"mcetoc_1i572omh715\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>int wordToNumber(char* word) {\n    int number = 0;\n    while (*word) {\n        number = number * 10 + (*word - 'a');\n        word++;\n    }\n    return number;\n}\n\nbool isSumEqual(char* firstWord, char* secondWord, char* targetWord) {\n    // 将 firstWord 和 secondWord 转换为数值\n    int firstValue = wordToNumber(firstWord);\n    int secondValue = wordToNumber(secondWord);\n    int targetValue = wordToNumber(targetWord);\n    \n    // 检查它们的数值之和是否等于 targetWord 的数值\n    return (firstValue + secondValue == targetValue);\n}</code></pre>\n<h3 id=\"mcetoc_1i572omh716\">解释</h3>\n<ul>\n<li>\n<p><strong><code>wordToNumber</code> 函数</strong>: 使用 <code>(*word - 'a')</code> 计算字母的字母值。例如，<code>'a'</code> 的 ASCII 值是 97，所以 <code>'a' - 'a'</code> 结果为 <code>0</code>，而 <code>'b' - 'a'</code> 结果为 <code>1</code>，以此类推。</p>\n</li>\n<li>\n<p><strong>主逻辑</strong>: 将 <code>firstWord</code> 和 <code>secondWord</code> 转换为数值并相加，然后与 <code>targetWord</code> 的数值进行比较。</p>\n</li>\n</ul>\n<p> </p>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-14T07:56:56+08:00",
            "date_modified": "2024-08-14T07:57:01+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/lcp-51-peng-ren-liao-li.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/lcp-51-peng-ren-liao-li.html",
            "title": "LCP 51. 烹饪料理",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i54fqr0a3m\">题目</a></li>\n<li><a href=\"#mcetoc_1i54fqr0a3n\">代码</a></li>\n<li><a href=\"#mcetoc_1i54fqr0a3o\">解释</a>\n<ul>\n<li><a href=\"#mcetoc_1i54fqr0a3p\">关键思路</a></li>\n<li><a href=\"#mcetoc_1i54fqr0a3q\">具体流程</a></li>\n<li><a href=\"#mcetoc_1i54fqr0a3r\">为什么不用动态规划？</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i54fqr0a3m\">题目</h3>\n<p>勇者背包内共有编号为 <code>0 ~ 4</code> 的五种食材，其中 <code>materials[j]</code> 表示第 <code>j</code> 种食材的数量。通过这些食材可以制作若干料理，<code>cookbooks[i][j]</code> 表示制作第 <code>i</code> 种料理需要第 <code>j</code> 种食材的数量，而 <code>attribute[i] = [x,y]</code> 表示第 <code>i</code> 道料理的美味度 <code>x</code> 和饱腹感 <code>y</code>。</p>\n<p>在饱腹感不小于 <code>limit</code> 的情况下，请返回勇者可获得的最大美味度。如果无法满足饱腹感要求，则返回 <code>-1</code>。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>每种料理只能制作一次。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<blockquote>\n<p>输入：<code>materials = [3,2,4,1,2]</code> <code>cookbooks = [[1,1,0,1,2],[2,1,4,0,0],[3,2,4,1,0]]</code> <code>attribute = [[3,2],[2,4],[7,6]]</code> <code>limit = 5</code></p>\n<p>输出：<code>7</code></p>\n<p>解释： 食材数量可以满足以下两种方案： 方案一：制作料理 0 和料理 1，可获得饱腹感 2+4、美味度 3+2 方案二：仅制作料理 2， 可饱腹感为 6、美味度为 7 因此在满足饱腹感的要求下，可获得最高美味度 7</p>\n</blockquote>\n<p><strong>示例 2：</strong></p>\n<blockquote>\n<p>输入：<code>materials = [10,10,10,10,10]</code> <code>cookbooks = [[1,1,1,1,1],[3,3,3,3,3],[10,10,10,10,10]]</code> <code>attribute = [[5,5],[6,6],[10,10]]</code> <code>limit = 1</code></p>\n<p>输出：<code>11</code></p>\n<p>解释：通过制作料理 0 和 1，可满足饱腹感，并获得最高美味度 11</p>\n</blockquote>\n<h3 id=\"mcetoc_1i54fqr0a3n\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>#include &lt;stdio.h&gt;\n\nint max(int a, int b) {\n    return a &gt; b ? a : b;\n}\n\nvoid dfs(int* materials, int materialsSize, int** cookbooks, int cookbooksSize, int** attribute, int limit, int index, int currentDelicious, int currentFullness, int* maxDelicious) {\n    // 如果当前饱腹感已经大于等于 limit\n    if (currentFullness &gt;= limit) {\n        *maxDelicious = max(*maxDelicious, currentDelicious);\n    }\n\n    // 遍历每一种料理\n    for (int i = index; i &lt; cookbooksSize; i++) {\n        int canCook = 1;\n\n        // 检查是否有足够的食材来制作这道料理\n        for (int j = 0; j &lt; materialsSize; j++) {\n            if (materials[j] &lt; cookbooks[i][j]) {\n                canCook = 0;\n                break;\n            }\n        }\n\n        if (canCook) {\n            // 做这道料理，更新材料剩余数量\n            for (int j = 0; j &lt; materialsSize; j++) {\n                materials[j] -= cookbooks[i][j];\n            }\n\n            // 递归调用，继续尝试制作下一道料理\n            dfs(materials, materialsSize, cookbooks, cookbooksSize, attribute, limit, i + 1, currentDelicious + attribute[i][0], currentFullness + attribute[i][1], maxDelicious);\n\n            // 回溯，恢复材料剩余数量\n            for (int j = 0; j &lt; materialsSize; j++) {\n                materials[j] += cookbooks[i][j];\n            }\n        }\n    }\n}\n\nint perfectMenu(int* materials, int materialsSize, int** cookbooks, int cookbooksSize, int* cookbooksColSize, int** attribute, int attributeSize, int* attributeColSize, int limit) {\n    int maxDelicious = -1;\n\n    dfs(materials, materialsSize, cookbooks, cookbooksSize, attribute, limit, 0, 0, 0, &amp;maxDelicious);\n\n    return maxDelicious;\n}\n</code></pre>\n<h3 id=\"mcetoc_1i54fqr0a3o\">解释</h3>\n<p>这道题的核心在于如何选择一组料理，使得在满足饱腹感的前提下，获得最大的美味度。这实际上是一个经典的「0-1 背包问题」的变种，只不过背包的容量和价值都多维化了，因此不能直接使用动态规划来解决，而是使用深度优先搜索（DFS）进行组合的枚举。</p>\n<h4 id=\"mcetoc_1i54fqr0a3p\">关键思路</h4>\n<ol>\n<li>\n<p><strong>深度优先搜索 (DFS)</strong>：DFS 是一种遍历或搜索树或图的算法。在这里，DFS 用来遍历所有可能的料理组合。通过递归的方法，我们从头到尾尝试每一种料理的组合。</p>\n</li>\n<li>\n<p><strong>剪枝（提前停止不必要的计算）</strong>：在递归过程中，首先检查当前的食材是否足够制作某个料理。如果某个料理需要的食材超出了勇者的拥有量，我们就不再继续下去，这样可以减少无效的搜索。</p>\n</li>\n<li>\n<p><strong>回溯</strong>：回溯是一种通过撤销某些选择来恢复原状的技术。在这道题中，当我们尝试制作某个料理时，会减少相应的食材数量；如果在接下来的搜索中发现这条路不合适，我们就会恢复食材的数量，然后尝试其他的组合。</p>\n</li>\n<li>\n<p><strong>终止条件</strong>：当我们遍历完所有可能的料理组合后，检查当前组合的饱腹感是否满足要求，如果满足，就更新最大美味度。</p>\n</li>\n<li>\n<p><strong>返回结果</strong>：最后，我们会返回遍历中找到的最大美味度值。如果遍历完所有组合后，没有任何一个组合能满足饱腹感要求，就返回 <code>-1</code>。</p>\n</li>\n</ol>\n<h4 id=\"mcetoc_1i54fqr0a3q\">具体流程</h4>\n<p>假设你有 5 种食材，可以制作若干种料理，每种料理都有特定的美味度和饱腹感。目标是在至少达到某个饱腹感的前提下，最大化获得的美味度。</p>\n<ul>\n<li>\n<p><strong>初始化</strong>：从第一个料理开始，初始的美味度和饱腹感为 <code>0</code>。</p>\n</li>\n<li>\n<p><strong>递归搜索</strong>：对于每个料理，我们有两种选择：要么制作它，要么不制作它。如果制作它，就更新当前的美味度和饱腹感，并减少相应的食材数量；然后递归地进行下一道料理的选择。</p>\n</li>\n<li>\n<p><strong>更新结果</strong>：每当发现一个新的组合能满足饱腹感要求时，比较其美味度是否超过当前已知的最大值。如果超过，则更新最大美味度。</p>\n</li>\n<li>\n<p><strong>回溯</strong>：在返回上一层递归之前，恢复之前减少的食材数量，确保其他组合的尝试不会受到影响。</p>\n</li>\n</ul>\n<h4 id=\"mcetoc_1i54fqr0a3r\">为什么不用动态规划？</h4>\n<p>动态规划通常用于处理「0-1 背包问题」，但这道题的复杂性在于：</p>\n<ul>\n<li>每种料理需要的食材种类不同，无法简单地用一个二维表来表示状态。</li>\n<li>需要对每种料理的组合进行判断，处理多个维度（美味度和饱腹感）的问题。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-13T07:47:41+08:00",
            "date_modified": "2024-08-13T07:47:41+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/859-qin-mi-zi-fu-chuan.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/859-qin-mi-zi-fu-chuan.html",
            "title": "859. 亲密字符串",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i51tpgc019\">题目</a></li>\n<li><a href=\"#mcetoc_1i51tpgc01a\">代码</a></li>\n<li><a href=\"#mcetoc_1i51tpgc01b\">解释</a></li>\n<li><a href=\"#mcetoc_1i51tpgc01c\">复杂度</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i51tpgc019\">题目</h3>\n<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回 <code>true</code> ；否则返回 <code>false</code> 。</p>\n<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>\n<ul>\n<li>例如，在 <code>\"abcd\"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>\"cbad\"</code> 。</li>\n</ul>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>s = \"ab\", goal = \"ba\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 相等。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>s = \"ab\", goal = \"ab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 不相等。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>s = \"aa\", goal = \"aa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 \"aa\"，此时 s 和 goal 相等。</pre>\n<h3 id=\"mcetoc_1i51tpgc01a\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>bool buddyStrings(char * s, char * goal) {\n    int len_s = strlen(s);\n    int len_goal = strlen(goal);\n\n    // 长度不同的情况\n    if (len_s != len_goal) {\n        return false;\n    }\n\n    // 如果字符串相同\n    if (strcmp(s, goal) == 0) {\n        // 检查是否有重复字符\n        int count[26] = {0};\n        for (int i = 0; i &lt; len_s; i++) {\n            count[s[i] - 'a']++;\n            if (count[s[i] - 'a'] &gt; 1) {\n                return true;\n            }\n        }\n        return false; // 没有重复字符，无法通过交换变为相同字符串\n    } else {\n        // 字符串不同的情况\n        int first = -1, second = -1;\n        for (int i = 0; i &lt; len_s; i++) {\n            if (s[i] != goal[i]) {\n                if (first == -1) {\n                    first = i;\n                } else if (second == -1) {\n                    second = i;\n                } else {\n                    return false; // 超过两个字符不同\n                }\n            }\n        }\n\n        // 确保只有两个字符不同且交换后相等\n        return (second != -1 &amp;&amp; s[first] == goal[second] &amp;&amp; s[second] == goal[first]);\n    }\n}</code></pre>\n<h3 id=\"mcetoc_1i51tpgc01b\">解释</h3>\n<ol>\n<li>\n<p><strong>长度检查</strong>：</p>\n<ul>\n<li>如果 <code>s</code> 和 <code>goal</code> 的长度不同，直接返回 <code>false</code>，因为无法通过任何交换使它们相等。</li>\n</ul>\n</li>\n<li>\n<p><strong>相等的字符串</strong>：</p>\n<ul>\n<li>如果 <code>s</code> 和 <code>goal</code> 完全相等，我们检查 <code>s</code> 中是否有重复字符。</li>\n<li>如果存在重复字符，返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>不相等的字符串</strong>：</p>\n<ul>\n<li>我们需要找出 <code>s</code> 和 <code>goal</code> 中不同的两个字符的位置，并检查这两个字符是否可以通过交换使 <code>s</code> 和 <code>goal</code> 相等。</li>\n<li>如果有两个不同的字符且交换后相等，返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"mcetoc_1i51tpgc01c\">复杂度</h3>\n<ul>\n<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。我们只需要一次遍历来完成检查。</li>\n<li><strong>空间复杂度</strong>：<code>O(1)</code>，仅使用了几个额外的变量用于计数和索引。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-12T07:53:59+08:00",
            "date_modified": "2024-08-12T07:53:59+08:00"
        }
    ]
}
