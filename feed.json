{
    "version": "https://jsonfeed.org/version/1",
    "title": "白衫如初",
    "description": "",
    "home_page_url": "https://hxfcoy.github.io/xcll.github.io",
    "feed_url": "https://hxfcoy.github.io/xcll.github.io/feed.json",
    "user_comment": "",
    "icon": "https://hxfcoy.github.io/xcll.github.io/media/website/LOGO.4a06cdd2.png",
    "author": {
        "name": "fcoy"
    },
    "items": [
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/2525-gen-ju-gui-ze-jiang-xiang-zi-fen-lei.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/2525-gen-ju-gui-ze-jiang-xiang-zi-fen-lei.html",
            "title": "2525. 根据规则将箱子分类",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i59kcaatr\">题目</a></li>\n<li><a href=\"#mcetoc_1i59kcaats\">代码</a></li>\n<li><a href=\"#mcetoc_1i59kcaatt\">解释</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i59kcaatr\">题目</h3>\n<p>给你四个整数 <code>length</code> ，<code>width</code> ，<code>height</code> 和 <code>mass</code> ，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 <strong>类别</strong> 的字符串。</p>\n<ul>\n<li>如果满足以下条件，那么箱子是 <code>\"Bulky\"</code> 的：\n<ul>\n<li>箱子 <strong>至少有一个</strong> 维度大于等于 <code>10<sup>4</sup></code> 。</li>\n<li>或者箱子的 <strong>体积</strong> 大于等于 <code>10<sup>9</sup></code> 。</li>\n</ul>\n</li>\n<li>如果箱子的质量大于等于 <code>100</code> ，那么箱子是 <code>\"Heavy\"</code> 的。</li>\n<li>如果箱子同时是 <code>\"Bulky\"</code> 和 <code>\"Heavy\"</code> ，那么返回类别为 <code>\"Both\"</code> 。</li>\n<li>如果箱子既不是 <code>\"Bulky\"</code> ，也不是 <code>\"Heavy\"</code> ，那么返回类别为 <code>\"Neither\"</code> 。</li>\n<li>如果箱子是 <code>\"Bulky\"</code> 但不是 <code>\"Heavy\"</code> ，那么返回类别为 <code>\"Bulky\"</code> 。</li>\n<li>如果箱子是 <code>\"Heavy\"</code> 但不是 <code>\"Bulky\"</code> ，那么返回类别为 <code>\"Heavy\"</code> 。</li>\n</ul>\n<p><strong>注意</strong>，箱子的体积等于箱子的长度、宽度和高度的乘积。</p>\n<h3 id=\"mcetoc_1i59kcaats\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>char* categorizeBox(int length, int width, int height, int mass) {\n    long long volume = (long long)length * width * height;\n    int isBulky = length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000 || volume &gt;= 1000000000;\n    int isHeavy = mass &gt;= 100;\n\n    if (isBulky &amp;&amp; isHeavy) {\n        return \"Both\";\n    } else if (isBulky) {\n        return \"Bulky\";\n    } else if (isHeavy) {\n        return \"Heavy\";\n    } else {\n        return \"Neither\";\n    }\n}</code></pre>\n<h3 id=\"mcetoc_1i59kcaatt\">解释</h3>\n<ol>\n<li>计算体积 <code>volume</code>。</li>\n<li>检查是否为“Bulky”：如果任一维度大于等于 10,000 或者体积大于等于 10^9，则标记为 Bulky。</li>\n<li>检查是否为“Heavy”：如果质量大于等于 100，则标记为 Heavy。</li>\n<li>根据条件返回相应的类别：<code>Both</code>、<code>Bulky</code>、<code>Heavy</code> 或 <code>Neither</code>。</li>\n</ol>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-15T07:43:20+08:00",
            "date_modified": "2024-08-15T07:43:20+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/1880-jian-cha-mou-dan-ci-shi-fou-deng-yu-liang-dan-ci-zhi-he.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/1880-jian-cha-mou-dan-ci-shi-fou-deng-yu-liang-dan-ci-zhi-he.html",
            "title": "1880. 检查某单词是否等于两单词之和",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i572omh714\">题目</a></li>\n<li><a href=\"#mcetoc_1i572omh715\">代码</a></li>\n<li><a href=\"#mcetoc_1i572omh716\">解释</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i572omh714\">题目</h3>\n<p>字母的 <strong>字母值</strong> 取决于字母在字母表中的位置，<strong>从 0 开始</strong> 计数。即，<code>'a' -&gt; 0</code>、<code>'b' -&gt; 1</code>、<code>'c' -&gt; 2</code>，以此类推。</p>\n<p>对某个由小写字母组成的字符串 <code>s</code> 而言，其 <strong>数值</strong> 就等于将 <code>s</code> 中每个字母的 <strong>字母值</strong> 按顺序 <strong>连接</strong> 并 <strong>转换</strong> 成对应整数。</p>\n<ul>\n<li>例如，<code>s = \"acb\"</code> ，依次连接每个字母的字母值可以得到 <code>\"021\"</code> ，转换为整数得到 <code>21</code> 。</li>\n</ul>\n<p>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成。</p>\n<p>如果 <code>firstWord</code><em> </em>和<em> </em><code>secondWord</code> 的 <strong>数值之和</strong> 等于<em> </em><code>targetWord</code><em> </em>的数值，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"acb\" -&gt; \"021\" -&gt; 21\nsecondWord 的数值为 \"cba\" -&gt; \"210\" -&gt; 210\ntargetWord 的数值为 \"cdb\" -&gt; \"231\" -&gt; 231\n由于 21 + 210 == 231 ，返回 true\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aab\" -&gt; \"001\" -&gt; 1\n由于 0 + 0 != 1 ，返回 false</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aaaa\" -&gt; \"0000\" -&gt; 0\n由于 0 + 0 == 0 ，返回 true</pre>\n<h3 id=\"mcetoc_1i572omh715\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>int wordToNumber(char* word) {\n    int number = 0;\n    while (*word) {\n        number = number * 10 + (*word - 'a');\n        word++;\n    }\n    return number;\n}\n\nbool isSumEqual(char* firstWord, char* secondWord, char* targetWord) {\n    // 将 firstWord 和 secondWord 转换为数值\n    int firstValue = wordToNumber(firstWord);\n    int secondValue = wordToNumber(secondWord);\n    int targetValue = wordToNumber(targetWord);\n    \n    // 检查它们的数值之和是否等于 targetWord 的数值\n    return (firstValue + secondValue == targetValue);\n}</code></pre>\n<h3 id=\"mcetoc_1i572omh716\">解释</h3>\n<ul>\n<li>\n<p><strong><code>wordToNumber</code> 函数</strong>: 使用 <code>(*word - 'a')</code> 计算字母的字母值。例如，<code>'a'</code> 的 ASCII 值是 97，所以 <code>'a' - 'a'</code> 结果为 <code>0</code>，而 <code>'b' - 'a'</code> 结果为 <code>1</code>，以此类推。</p>\n</li>\n<li>\n<p><strong>主逻辑</strong>: 将 <code>firstWord</code> 和 <code>secondWord</code> 转换为数值并相加，然后与 <code>targetWord</code> 的数值进行比较。</p>\n</li>\n</ul>\n<p> </p>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-14T07:56:56+08:00",
            "date_modified": "2024-08-14T07:57:01+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/lcp-51-peng-ren-liao-li.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/lcp-51-peng-ren-liao-li.html",
            "title": "LCP 51. 烹饪料理",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i54fqr0a3m\">题目</a></li>\n<li><a href=\"#mcetoc_1i54fqr0a3n\">代码</a></li>\n<li><a href=\"#mcetoc_1i54fqr0a3o\">解释</a>\n<ul>\n<li><a href=\"#mcetoc_1i54fqr0a3p\">关键思路</a></li>\n<li><a href=\"#mcetoc_1i54fqr0a3q\">具体流程</a></li>\n<li><a href=\"#mcetoc_1i54fqr0a3r\">为什么不用动态规划？</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i54fqr0a3m\">题目</h3>\n<p>勇者背包内共有编号为 <code>0 ~ 4</code> 的五种食材，其中 <code>materials[j]</code> 表示第 <code>j</code> 种食材的数量。通过这些食材可以制作若干料理，<code>cookbooks[i][j]</code> 表示制作第 <code>i</code> 种料理需要第 <code>j</code> 种食材的数量，而 <code>attribute[i] = [x,y]</code> 表示第 <code>i</code> 道料理的美味度 <code>x</code> 和饱腹感 <code>y</code>。</p>\n<p>在饱腹感不小于 <code>limit</code> 的情况下，请返回勇者可获得的最大美味度。如果无法满足饱腹感要求，则返回 <code>-1</code>。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>每种料理只能制作一次。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<blockquote>\n<p>输入：<code>materials = [3,2,4,1,2]</code> <code>cookbooks = [[1,1,0,1,2],[2,1,4,0,0],[3,2,4,1,0]]</code> <code>attribute = [[3,2],[2,4],[7,6]]</code> <code>limit = 5</code></p>\n<p>输出：<code>7</code></p>\n<p>解释： 食材数量可以满足以下两种方案： 方案一：制作料理 0 和料理 1，可获得饱腹感 2+4、美味度 3+2 方案二：仅制作料理 2， 可饱腹感为 6、美味度为 7 因此在满足饱腹感的要求下，可获得最高美味度 7</p>\n</blockquote>\n<p><strong>示例 2：</strong></p>\n<blockquote>\n<p>输入：<code>materials = [10,10,10,10,10]</code> <code>cookbooks = [[1,1,1,1,1],[3,3,3,3,3],[10,10,10,10,10]]</code> <code>attribute = [[5,5],[6,6],[10,10]]</code> <code>limit = 1</code></p>\n<p>输出：<code>11</code></p>\n<p>解释：通过制作料理 0 和 1，可满足饱腹感，并获得最高美味度 11</p>\n</blockquote>\n<h3 id=\"mcetoc_1i54fqr0a3n\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>#include &lt;stdio.h&gt;\n\nint max(int a, int b) {\n    return a &gt; b ? a : b;\n}\n\nvoid dfs(int* materials, int materialsSize, int** cookbooks, int cookbooksSize, int** attribute, int limit, int index, int currentDelicious, int currentFullness, int* maxDelicious) {\n    // 如果当前饱腹感已经大于等于 limit\n    if (currentFullness &gt;= limit) {\n        *maxDelicious = max(*maxDelicious, currentDelicious);\n    }\n\n    // 遍历每一种料理\n    for (int i = index; i &lt; cookbooksSize; i++) {\n        int canCook = 1;\n\n        // 检查是否有足够的食材来制作这道料理\n        for (int j = 0; j &lt; materialsSize; j++) {\n            if (materials[j] &lt; cookbooks[i][j]) {\n                canCook = 0;\n                break;\n            }\n        }\n\n        if (canCook) {\n            // 做这道料理，更新材料剩余数量\n            for (int j = 0; j &lt; materialsSize; j++) {\n                materials[j] -= cookbooks[i][j];\n            }\n\n            // 递归调用，继续尝试制作下一道料理\n            dfs(materials, materialsSize, cookbooks, cookbooksSize, attribute, limit, i + 1, currentDelicious + attribute[i][0], currentFullness + attribute[i][1], maxDelicious);\n\n            // 回溯，恢复材料剩余数量\n            for (int j = 0; j &lt; materialsSize; j++) {\n                materials[j] += cookbooks[i][j];\n            }\n        }\n    }\n}\n\nint perfectMenu(int* materials, int materialsSize, int** cookbooks, int cookbooksSize, int* cookbooksColSize, int** attribute, int attributeSize, int* attributeColSize, int limit) {\n    int maxDelicious = -1;\n\n    dfs(materials, materialsSize, cookbooks, cookbooksSize, attribute, limit, 0, 0, 0, &amp;maxDelicious);\n\n    return maxDelicious;\n}\n</code></pre>\n<h3 id=\"mcetoc_1i54fqr0a3o\">解释</h3>\n<p>这道题的核心在于如何选择一组料理，使得在满足饱腹感的前提下，获得最大的美味度。这实际上是一个经典的「0-1 背包问题」的变种，只不过背包的容量和价值都多维化了，因此不能直接使用动态规划来解决，而是使用深度优先搜索（DFS）进行组合的枚举。</p>\n<h4 id=\"mcetoc_1i54fqr0a3p\">关键思路</h4>\n<ol>\n<li>\n<p><strong>深度优先搜索 (DFS)</strong>：DFS 是一种遍历或搜索树或图的算法。在这里，DFS 用来遍历所有可能的料理组合。通过递归的方法，我们从头到尾尝试每一种料理的组合。</p>\n</li>\n<li>\n<p><strong>剪枝（提前停止不必要的计算）</strong>：在递归过程中，首先检查当前的食材是否足够制作某个料理。如果某个料理需要的食材超出了勇者的拥有量，我们就不再继续下去，这样可以减少无效的搜索。</p>\n</li>\n<li>\n<p><strong>回溯</strong>：回溯是一种通过撤销某些选择来恢复原状的技术。在这道题中，当我们尝试制作某个料理时，会减少相应的食材数量；如果在接下来的搜索中发现这条路不合适，我们就会恢复食材的数量，然后尝试其他的组合。</p>\n</li>\n<li>\n<p><strong>终止条件</strong>：当我们遍历完所有可能的料理组合后，检查当前组合的饱腹感是否满足要求，如果满足，就更新最大美味度。</p>\n</li>\n<li>\n<p><strong>返回结果</strong>：最后，我们会返回遍历中找到的最大美味度值。如果遍历完所有组合后，没有任何一个组合能满足饱腹感要求，就返回 <code>-1</code>。</p>\n</li>\n</ol>\n<h4 id=\"mcetoc_1i54fqr0a3q\">具体流程</h4>\n<p>假设你有 5 种食材，可以制作若干种料理，每种料理都有特定的美味度和饱腹感。目标是在至少达到某个饱腹感的前提下，最大化获得的美味度。</p>\n<ul>\n<li>\n<p><strong>初始化</strong>：从第一个料理开始，初始的美味度和饱腹感为 <code>0</code>。</p>\n</li>\n<li>\n<p><strong>递归搜索</strong>：对于每个料理，我们有两种选择：要么制作它，要么不制作它。如果制作它，就更新当前的美味度和饱腹感，并减少相应的食材数量；然后递归地进行下一道料理的选择。</p>\n</li>\n<li>\n<p><strong>更新结果</strong>：每当发现一个新的组合能满足饱腹感要求时，比较其美味度是否超过当前已知的最大值。如果超过，则更新最大美味度。</p>\n</li>\n<li>\n<p><strong>回溯</strong>：在返回上一层递归之前，恢复之前减少的食材数量，确保其他组合的尝试不会受到影响。</p>\n</li>\n</ul>\n<h4 id=\"mcetoc_1i54fqr0a3r\">为什么不用动态规划？</h4>\n<p>动态规划通常用于处理「0-1 背包问题」，但这道题的复杂性在于：</p>\n<ul>\n<li>每种料理需要的食材种类不同，无法简单地用一个二维表来表示状态。</li>\n<li>需要对每种料理的组合进行判断，处理多个维度（美味度和饱腹感）的问题。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-13T07:47:41+08:00",
            "date_modified": "2024-08-13T07:47:41+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/859-qin-mi-zi-fu-chuan.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/859-qin-mi-zi-fu-chuan.html",
            "title": "859. 亲密字符串",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i51tpgc019\">题目</a></li>\n<li><a href=\"#mcetoc_1i51tpgc01a\">代码</a></li>\n<li><a href=\"#mcetoc_1i51tpgc01b\">解释</a></li>\n<li><a href=\"#mcetoc_1i51tpgc01c\">复杂度</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i51tpgc019\">题目</h3>\n<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回 <code>true</code> ；否则返回 <code>false</code> 。</p>\n<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>\n<ul>\n<li>例如，在 <code>\"abcd\"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>\"cbad\"</code> 。</li>\n</ul>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>s = \"ab\", goal = \"ba\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 相等。</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>s = \"ab\", goal = \"ab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 不相等。</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>s = \"aa\", goal = \"aa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 \"aa\"，此时 s 和 goal 相等。</pre>\n<h3 id=\"mcetoc_1i51tpgc01a\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>bool buddyStrings(char * s, char * goal) {\n    int len_s = strlen(s);\n    int len_goal = strlen(goal);\n\n    // 长度不同的情况\n    if (len_s != len_goal) {\n        return false;\n    }\n\n    // 如果字符串相同\n    if (strcmp(s, goal) == 0) {\n        // 检查是否有重复字符\n        int count[26] = {0};\n        for (int i = 0; i &lt; len_s; i++) {\n            count[s[i] - 'a']++;\n            if (count[s[i] - 'a'] &gt; 1) {\n                return true;\n            }\n        }\n        return false; // 没有重复字符，无法通过交换变为相同字符串\n    } else {\n        // 字符串不同的情况\n        int first = -1, second = -1;\n        for (int i = 0; i &lt; len_s; i++) {\n            if (s[i] != goal[i]) {\n                if (first == -1) {\n                    first = i;\n                } else if (second == -1) {\n                    second = i;\n                } else {\n                    return false; // 超过两个字符不同\n                }\n            }\n        }\n\n        // 确保只有两个字符不同且交换后相等\n        return (second != -1 &amp;&amp; s[first] == goal[second] &amp;&amp; s[second] == goal[first]);\n    }\n}</code></pre>\n<h3 id=\"mcetoc_1i51tpgc01b\">解释</h3>\n<ol>\n<li>\n<p><strong>长度检查</strong>：</p>\n<ul>\n<li>如果 <code>s</code> 和 <code>goal</code> 的长度不同，直接返回 <code>false</code>，因为无法通过任何交换使它们相等。</li>\n</ul>\n</li>\n<li>\n<p><strong>相等的字符串</strong>：</p>\n<ul>\n<li>如果 <code>s</code> 和 <code>goal</code> 完全相等，我们检查 <code>s</code> 中是否有重复字符。</li>\n<li>如果存在重复字符，返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>不相等的字符串</strong>：</p>\n<ul>\n<li>我们需要找出 <code>s</code> 和 <code>goal</code> 中不同的两个字符的位置，并检查这两个字符是否可以通过交换使 <code>s</code> 和 <code>goal</code> 相等。</li>\n<li>如果有两个不同的字符且交换后相等，返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"mcetoc_1i51tpgc01c\">复杂度</h3>\n<ul>\n<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。我们只需要一次遍历来完成检查。</li>\n<li><strong>空间复杂度</strong>：<code>O(1)</code>，仅使用了几个额外的变量用于计数和索引。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-12T07:53:59+08:00",
            "date_modified": "2024-08-12T07:53:59+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/551-xue-sheng-chu-qin-ji-lu-i.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/551-xue-sheng-chu-qin-ji-lu-i.html",
            "title": "551. 学生出勤记录 I",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i4vbu31bv\">题目</a></li>\n<li><a href=\"#mcetoc_1i4vbu31b10\">代码</a></li>\n<li><a href=\"#mcetoc_1i4vbu31b11\">代码解析</a></li>\n<li><a href=\"#mcetoc_1i4vbu31b12\">复杂度</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i4vbu31bv\">题目</h3>\n<p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>\n<ul>\n<li><code>'A'</code>：Absent，缺勤</li>\n<li><code>'L'</code>：Late，迟到</li>\n<li><code>'P'</code>：Present，到场</li>\n</ul>\n<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n<ul>\n<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>\n<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>\n</ul>\n<p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>s = \"PPALLP\"\n<strong>输出：</strong>true\n<strong>解释：</strong>学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>s = \"PPALLL\"\n<strong>输出：</strong>false\n<strong>解释：</strong>学生最后三天连续迟到，所以不满足出勤奖励的条件。</pre>\n<h3 id=\"mcetoc_1i4vbu31b10\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>bool checkRecord(char* s) {\n    int countA = 0;       // 用来统计 'A' 的数量\n    int consecutiveL = 0; // 用来统计连续 'L' 的数量\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (s[i] == 'A') {\n            countA++;\n            if (countA &gt;= 2) { // 如果 'A' 的数量达到 2，直接返回 false\n                return false;\n            }\n        }\n\n        if (s[i] == 'L') {\n            consecutiveL++;\n            if (consecutiveL &gt;=\n                3) { // 如果连续 'L' 的数量达到 3，直接返回 false\n                return false;\n            }\n        } else {\n            consecutiveL = 0; // 如果当前字符不是 'L'，重置连续 'L' 计数\n        }\n    }\n\n    return true; // 如果两个条件都未触发，则返回 true\n}</code></pre>\n<h3 id=\"mcetoc_1i4vbu31b11\">代码解析</h3>\n<ol>\n<li>\n<p><strong>计数缺勤天数 <code>countA</code></strong>：</p>\n<ul>\n<li>每次遇到字符 <code>'A'</code>，<code>countA</code> 自增。</li>\n<li>如果 <code>countA</code> 达到或超过 2，说明缺勤天数不满足要求，直接返回 <code>false</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>统计连续迟到天数 <code>consecutiveL</code></strong>：</p>\n<ul>\n<li>每次遇到字符 <code>'L'</code>，<code>consecutiveL</code> 自增。</li>\n<li>如果 <code>consecutiveL</code> 达到或超过 3，说明存在连续 3 天或以上的迟到，直接返回 <code>false</code>。</li>\n<li>一旦遇到非 <code>'L'</code> 字符，<code>consecutiveL</code> 归零，重新开始统计。</li>\n</ul>\n</li>\n<li>\n<p><strong>返回结果</strong>：</p>\n<ul>\n<li>如果遍历结束后没有触发以上两个条件，则返回 <code>true</code>，表示可以获得出勤奖励。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"mcetoc_1i4vbu31b12\">复杂度</h3>\n<ul>\n<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是字符串的长度。只需遍历字符串一次即可。</li>\n<li><strong>空间复杂度</strong>：<code>O(1)</code>，只使用了几个固定大小的变量来记录状态。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-11T08:03:28+08:00",
            "date_modified": "2024-08-11T08:03:28+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/234-hui-wen-lian-biao.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/234-hui-wen-lian-biao.html",
            "title": "234. 回文链表",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i4vbdq181\">题目</a></li>\n<li><a href=\"#mcetoc_1i4vb84nj2h\">代码</a></li>\n<li><a href=\"#mcetoc_1i4vb84nj2i\">解释</a></li>\n<li><a href=\"#mcetoc_1i4vb8mh82k\">复杂度</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i4vbdq181\">题目</h3>\n<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为</p>\n<div class=\"popover-wrapper inline-block\" data-headlessui-state=\"\">\n<div>\n<div id=\"headlessui-popover-button-:rah:\" aria-expanded=\"false\" data-headlessui-state=\"\">\n<div>回文链表</div>\n</div>\n<div> </div>\n</div>\n</div>\n<p>。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<p><img loading=\"lazy\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg\" alt=\"\" data-is-external-image=\"true\"></p>\n<pre><strong>输入：</strong>head = [1,2,2,1]\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 2：</strong></p>\n<p><img loading=\"lazy\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg\" alt=\"\" data-is-external-image=\"true\"></p>\n<pre><strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>falsed</pre>\n<h3 id=\"mcetoc_1i4vb84nj2h\">代码</h3>\n<pre class=\"language-c line-numbers\"><code>struct ListNode* middle_find(struct ListNode* head) {\n    struct ListNode* slow = head;\n    struct ListNode* fast = head-&gt;next;\n\n    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {\n        slow = slow-&gt;next;\n        fast = fast-&gt;next-&gt;next;\n    }\n    return slow;\n}\n\nstruct ListNode* reverse(struct ListNode* right_head) {\n    struct ListNode* new_head = NULL;\n    while (right_head != NULL) {\n        struct ListNode* next = right_head-&gt;next;\n        right_head-&gt;next = new_head;\n        new_head = right_head;\n        right_head = next;\n    }\n    return new_head;\n}\n\nbool isPalindrome(struct ListNode* head) {\n    if (head == NULL) {\n        return NULL;\n    }\n\n    struct ListNode* middle = middle_find(head);\n    struct ListNode* right = reverse(middle-&gt;next);\n    struct ListNode* right_copy = right;\n    struct ListNode* tmp = head;\n\n    while (tmp != NULL &amp;&amp; right_copy != NULL) {\n        if (tmp-&gt;val != right_copy-&gt;val) {\n            return false;\n        }\n        tmp = tmp-&gt;next;\n        right_copy = right_copy-&gt;next;\n    }\n\n    middle-&gt;next = reverse(right);\n    return true;\n}</code></pre>\n<h3 id=\"mcetoc_1i4vb84nj2i\">解释</h3>\n<ul>\n<li>\n<p><strong><code>middle_find</code> 函数</strong>:</p>\n<ul>\n<li>这个函数的目的是找到链表的中间节点。</li>\n<li>使用了<strong>快慢指针</strong>技术：\n<ul>\n<li><code>slow</code> 指针每次移动一步。</li>\n<li><code>fast</code> 指针每次移动两步。</li>\n</ul>\n</li>\n<li>当 <code>fast</code> 指针到达链表的末尾时，<code>slow</code> 指针正好位于链表的中间。</li>\n<li>返回的 <code>slow</code> 指针指向链表的中间节点。</li>\n</ul>\n</li>\n<li>\n<p><strong><code>reverse</code> 函数</strong>:</p>\n<ul>\n<li>这个函数的目的是反转从 <code>right_head</code> 开始的链表。</li>\n<li>使用了三个指针来反转链表：\n<ul>\n<li><code>new_head</code> 用来指向反转后的链表的头部（最初为 <code>NULL</code>）。</li>\n<li><code>right_head</code> 用来遍历链表，逐个反转节点。</li>\n<li><code>next</code> 用来临时保存当前节点的下一个节点，以便在反转后继续遍历。</li>\n</ul>\n</li>\n<li>函数返回反转后的链表头节点 <code>new_head</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong><code>isPalindrome</code> 函数</strong>:</p>\n<ul>\n<li>这是主函数，用来判断给定链表是否为回文链表。</li>\n<li>如果链表为空（即 <code>head</code> 为 <code>NULL</code>），直接返回 <code>NULL</code>（应返回 <code>false</code>，可能是个小错误）。</li>\n<li>通过 <code>middle_find</code> 函数找到链表的中间节点。</li>\n<li>反转中间节点后的右半部分链表，并将新头节点赋值给 <code>right</code>。</li>\n<li>创建两个指针 <code>right_copy</code> 和 <code>tmp</code>，分别用于遍历反转后的右半部分链表和原始链表的左半部分。</li>\n<li>通过遍历比较左半部分链表和右半部分反转链表的对应节点的值。</li>\n<li>如果发现任何一对节点的值不相等，立即返回 <code>false</code>。</li>\n<li>如果比较通过，链表是回文的，最后将反转的右半部分链表再次反转回来，恢复原链表的结构。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mcetoc_1i4vb8mh82k\">复杂度</h3>\n<ul>\n<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是链表的长度，因为我们只对链表进行了一次遍历和一次反转。</li>\n<li><strong>空间复杂度</strong>：<code>O(1)</code>，除了几个指针变量外，没有使用额外的空间。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-11T07:51:41+08:00",
            "date_modified": "2024-08-11T07:54:23+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/20-you-xiao-de-gua-hao.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/20-you-xiao-de-gua-hao.html",
            "title": "20. 有效的括号",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i4vbe4li3\">题目</a></li>\n<li><a href=\"#mcetoc_1i4v90abed\">代码实现</a></li>\n<li><a href=\"#mcetoc_1i4v90abee\">代码解析</a></li>\n<li><a href=\"#mcetoc_1i4v90abef\">时间复杂度</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1i4vbe4li3\">题目</h3>\n<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n<li>每个右括号都有一个对应的相同类型的左括号。</li>\n</ol>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>s = \"()\"\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>s = \"()[]{}\"\n<strong>输出：</strong>true\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>s = \"(]\"\n<strong>输出：</strong>false</pre>\n<h3 id=\"mcetoc_1i4v90abed\">代码实现</h3>\n<pre class=\"language-c line-numbers\"><code>bool isValid(char* s) {\n    int n = strlen(s);\n    // 如果字符串长度是奇数，直接返回 false\n    if (n % 2 != 0) {\n        return false;\n    }\n\n    // 用一个数组模拟栈\n    char stack[n];\n    int top = -1;\n\n    for (int i = 0; i &lt; n; i++) {\n        char c = s[i];\n        if (c == '(' || c == '{' || c == '[') {\n            // 将左括号压入栈中\n            stack[++top] = c;\n        } else {\n            // 遇到右括号时，检查栈顶元素是否匹配\n            if (top == -1) {\n                return false;\n            }\n            char topChar = stack[top];\n            if ((c == ')' &amp;&amp; topChar != '(') ||\n                (c == '}' &amp;&amp; topChar != '{') ||\n                (c == ']' &amp;&amp; topChar != '[')) {\n                return false;\n            }\n            // 弹出栈顶元素\n            top--;\n        }\n    }\n\n    // 如果栈为空，所有括号都匹配\n    return top == -1;\n}</code></pre>\n<h3 id=\"mcetoc_1i4v90abee\">代码解析</h3>\n<ol>\n<li>\n<p><strong>栈的模拟</strong>：我们用一个数组 <code>stack</code> 来模拟栈，并用 <code>top</code> 指针表示栈顶。</p>\n<ul>\n<li>当遇到左括号时，将其压入栈中。</li>\n<li>当遇到右括号时，检查栈顶是否有匹配的左括号。</li>\n<li>如果匹配，弹出栈顶的元素；否则返回 <code>false</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>字符串长度检查</strong>：如果字符串长度是奇数，则直接返回 <code>false</code>，因为不可能存在配对的括号。</p>\n</li>\n<li>\n<p><strong>最终检查</strong>：在遍历完字符串后，检查栈是否为空。如果栈为空，说明所有的括号都成功匹配，否则返回 <code>false</code>。</p>\n</li>\n</ol>\n<h3 id=\"mcetoc_1i4v90abef\">时间复杂度</h3>\n<ul>\n<li><strong>时间复杂度</strong>: 每个字符都要入栈或出栈，时间复杂度是 <code>O(n)</code>，其中 <code>n</code> 是字符串的长度。</li>\n<li><strong>空间复杂度</strong>: 最坏情况下栈的大小为 <code>n/2</code>，因此空间复杂度也是 <code>O(n)</code>。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-11T07:12:12+08:00",
            "date_modified": "2024-08-11T07:54:32+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/15-san-shu-zhi-he.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/15-san-shu-zhi-he.html",
            "title": "15. 三数之和",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i4u8qoul21\">实现代码</a></li>\n<li><a href=\"#mcetoc_1i4u8jjga1r\">解释</a>\n<ul>\n<li><a href=\"#mcetoc_1i4u8jjga1s\">时间复杂度</a></li>\n<li><a href=\"#mcetoc_1i4u8jjga1t\">空间复杂度</a></li>\n</ul>\n</li>\n<li><a href=\"#mcetoc_1i4u8jjga1u\">cmp解释</a>\n<ul>\n<li><a href=\"#mcetoc_1i4u8jjga1v\">返回值的含义</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h3>题目</h3>\n<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n<p> </p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n<strong>解释：</strong>\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [0,1,1]\n<strong>输出：</strong>[]\n<strong>解释：</strong>唯一可能的三元组和不为 0 。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>[[0,0,0]]\n<strong>解释：</strong>唯一可能的三元组和为 0 。</pre>\n<h3 id=\"mcetoc_1i4u8qoul21\">实现代码</h3>\n<pre class=\"language-c line-numbers\"><code>int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    int cmp(const void* a, const void* b) {\n    return *(int*)a - *(int*)b;\n}\n    *returnSize = 0;\n    if (numsSize &lt; 3) {\n        return NULL;\n    }\n\n    // 先对数组排序\n    qsort(nums, numsSize, sizeof(int), cmp);\n\n    int** result = (int**)malloc(numsSize * numsSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(numsSize * numsSize * sizeof(int));\n\n    for (int i = 0; i &lt; numsSize - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue; // 跳过重复的元素\n        }\n\n        int left = i + 1;\n        int right = numsSize - 1;\n\n        while (left &lt; right) {\n            int sum = nums[i] + nums[left] + nums[right];\n\n            if (sum == 0) {\n                // 找到一组符合条件的三元组\n                result[*returnSize] = (int*)malloc(3 * sizeof(int));\n                result[*returnSize][0] = nums[i];\n                result[*returnSize][1] = nums[left];\n                result[*returnSize][2] = nums[right];\n                (*returnColumnSizes)[*returnSize] = 3;\n                (*returnSize)++;\n\n                // 移动指针并跳过重复的元素\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n\n                left++;\n                right--;\n            } else if (sum &lt; 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n\n    return result;\n}</code></pre>\n<h3 id=\"mcetoc_1i4u8jjga1r\">解释</h3>\n<ol>\n<li>\n<p><strong>排序</strong>：我们首先对数组进行排序，这样可以更容易地避免重复的三元组，同时可以利用排序后的数组进行双指针的查找。</p>\n</li>\n<li>\n<p><strong>双指针查找</strong>：</p>\n<ul>\n<li>固定一个数 <code>nums[i]</code>，然后使用双指针在 <code>nums[i+1]</code> 到 <code>nums[numsSize-1]</code> 之间寻找两个数使得三数之和为0。</li>\n<li>如果找到满足条件的三元组，加入结果集，然后移动双指针，同时跳过重复的元素。</li>\n</ul>\n</li>\n<li>\n<p><strong>跳过重复</strong>：在外层循环和双指针循环中，如果发现当前元素与上一个元素相同，则跳过，避免重复三元组的出现。</p>\n</li>\n<li>\n<p><strong>返回结果</strong>：</p>\n<ul>\n<li><code>returnSize</code>：表示返回的三元组的个数。</li>\n<li><code>returnColumnSizes</code>：表示每个三元组的大小（都是3）。</li>\n<li>返回的 <code>result</code> 是一个二维数组，包含所有符合条件的三元组。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"mcetoc_1i4u8jjga1s\">时间复杂度</h4>\n<ul>\n<li><strong>排序</strong>的时间复杂度是 <code>O(n log n)</code>。</li>\n<li>外层循环和内层双指针循环的复杂度是 <code>O(n^2)</code>。</li>\n</ul>\n<p>因此，整体的时间复杂度为 <code>O(n^2)</code>。</p>\n<h4 id=\"mcetoc_1i4u8jjga1t\">空间复杂度</h4>\n<ul>\n<li>主要用于存储结果的二维数组，最坏情况下需要 <code>O(n^2)</code> 的空间。</li>\n</ul>\n<h3 id=\"mcetoc_1i4u8jjga1u\">cmp解释</h3>\n<pre class=\"language-c line-numbers\"><code>int cmp(const void* a, const void* b) {\n    return *(int*)a - *(int*)b;\n}</code></pre>\n<ul>\n<li>\n<p><code>*(int*)a</code>：这个表达式首先将 <code>void*</code> 类型的指针 <code>a</code> 转换为 <code>int*</code> 类型的指针，然后通过 <code>*</code> 操作符解引用，获取该内存位置存储的整数值。</p>\n</li>\n<li>\n<p><code>*(int*)b</code>：同样地，将 <code>void*</code> 类型的指针 <code>b</code> 转换为 <code>int*</code> 类型的指针，然后解引用获取整数值。</p>\n</li>\n<li>\n<p><code>*(int*)a - *(int*)b</code>：通过相减，比较这两个整数的大小。</p>\n</li>\n</ul>\n<h4 id=\"mcetoc_1i4u8jjga1v\">返回值的含义</h4>\n<ul>\n<li>如果 <code>*(int*)a</code> 比 <code>*(int*)b</code> 小，则返回一个负数。这表示在排序过程中，<code>a</code> 应该排在 <code>b</code> 之前。</li>\n<li>如果 <code>*(int*)a</code> 比 <code>*(int*)b</code> 大，则返回一个正数，表示 <code>a</code> 应该排在 <code>b</code> 之后。</li>\n<li>如果 <code>*(int*)a</code> 和 <code>*(int*)b</code> 相等，则返回 0，表示它们在排序中的位置相同。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T21:38:37+08:00",
            "date_modified": "2024-08-11T07:54:42+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/2582-di-zhen-tou.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/2582-di-zhen-tou.html",
            "title": "2582. 递枕头",
            "content_html": "<p><code>n</code> 个人站成一排，按从 <code>1</code> 到 <code>n</code> 编号。最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。</p>\n<ul>\n<li>例如，当枕头到达第 <code>n</code> 个人时，TA 会将枕头传递给第 <code>n - 1</code> 个人，然后传递给第 <code>n - 2</code> 个人，依此类推。</li>\n</ul>\n<p>给你两个正整数 <code>n</code> 和 <code>time</code> ，返回 <code>time</code> 秒后拿着枕头的人的编号。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 4, time = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 3 -&gt; 2 。\n5 秒后，枕头传递到第 2 个人手中。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 3, time = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 。\n2 秒后，枕头传递到第 3 个人手中。</pre>\n<pre class=\"language-c line-numbers\"><code>int passThePillow(int n, int time) {\n    // 如果time对(n-1)取模，则time % (n-1) 表示经过几个完整的正向传递后的余数\n    // 通过方向(正向或反向)计算最终位置\n    int cycle = time / (n - 1);\n    int remainder = time % (n - 1);\n\n    // 如果cycle是偶数，枕头在正向传递，位置为 1 + remainder\n    // 如果cycle是奇数，枕头在反向传递，位置为 n - remainder\n    if (cycle % 2 == 0) {\n        return 1 + remainder;\n    } else {\n        return n - remainder;\n    }\n}</code></pre>\n<ul>\n<li>\n<p><strong>循环次数</strong>：枕头传递方向的改变仅在到达队首或队尾时发生。如果将一个完整的往返（从第1个人传递到第n个人再回到第1个人）视为一个循环，枕头在经过一个完整的循环后又回到了初始位置。</p>\n</li>\n<li>\n<p><strong>方向和位置计算</strong>：</p>\n<ul>\n<li>假设当前方向为正向（从第1个人向第n个人传递），则枕头每秒传递到下一个人。</li>\n<li>一旦到达第n个人，方向就会反向，接下来每秒传递给前一个人。</li>\n</ul>\n</li>\n<li>\n<p><strong>计算逻辑</strong>：</p>\n<ul>\n<li>如果 <code>time</code> 的值加上初始位置是在第一个方向的范围内，则只需直接计算出具体位置。</li>\n<li>如果在反方向范围内，也能通过简单的计算得到。</li>\n</ul>\n</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T21:30:43+08:00",
            "date_modified": "2024-08-10T21:30:43+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/lcr-166-zhu-bao-de-zui-gao-jie-zhi.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/lcr-166-zhu-bao-de-zui-gao-jie-zhi.html",
            "title": "LCR 166. 珠宝的最高价值",
            "content_html": "<p>现有一个记作二维矩阵 <code>frame</code> 的珠宝架，其中 <code>frame[i][j]</code> 为该位置珠宝的价值。拿取珠宝的规则为：</p>\n<ul>\n<li>只能从架子的左上角开始拿珠宝</li>\n<li>每次可以移动到右侧或下侧的相邻位置</li>\n<li>到达珠宝架子的右下角时，停止拿取</li>\n</ul>\n<p>注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 <code>frame = [[0]]</code>。</p>\n<p> </p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> frame = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>输出:</strong> <code>12\n</code><strong>解释:</strong> 路径 1→3→5→2→1 可以拿到最高价值的珠宝</pre>\n<pre class=\"language-apacheconf line-numbers\"><code>int jewelleryValue(int** frame, int frameSize, int* frameColSize) {\n    if (frameSize == 0 || frameColSize[0] == 0) {\n        return 0; // 处理空架子的情况\n    }\n\n    int dp[frameSize][frameColSize[0]];\n\n    // 初始化 dp 数组\n    dp[0][0] = frame[0][0];\n\n    // 初始化第一列\n    for (int i = 1; i &lt; frameSize; i++) {\n        dp[i][0] = dp[i-1][0] + frame[i][0];\n    }\n\n    // 初始化第一行\n    for (int j = 1; j &lt; frameColSize[0]; j++) {\n        dp[0][j] = dp[0][j-1] + frame[0][j];\n    }\n\n    // 填充剩余的 dp 表格\n    for (int i = 1; i &lt; frameSize; i++) {\n        for (int j = 1; j &lt; frameColSize[0]; j++) {\n            dp[i][j] = frame[i][j] + (dp[i-1][j] &gt; dp[i][j-1] ? dp[i-1][j] : dp[i][j-1]);\n        }\n    }\n\n    // 返回右下角的最大值\n    return dp[frameSize-1][frameColSize[0]-1];\n}\n</code></pre>\n<h3>动态规划思想</h3>\n<p>动态规划的核心思想是通过记录子问题的解来避免重复计算。我们用一个二维数组 <code>dp</code> 来存储从左上角到某个位置的最大珠宝总价值。</p>\n<h4>1. <strong>定义状态</strong>：</h4>\n<ul>\n<li>设 <code>dp[i][j]</code> 表示从左上角 <code>(0, 0)</code> 到位置 <code>(i, j)</code> 的最大珠宝价值。</li>\n</ul>\n<h4>2. <strong>状态转移方程</strong>：</h4>\n<ul>\n<li>由于只能向右或向下移动，所以 <code>dp[i][j]</code> 可以从左侧的 <code>dp[i][j-1]</code> 或上方的 <code>dp[i-1][j]</code> 位置到达。因此，状态转移方程为： <img loading=\"lazy\" src=\"file:///C:\\Users\\22501\\AppData\\Local\\Temp\\QQ_1723250937888.png\" data-is-external-image=\"true\">\n<ul>\n<li>这表示从 <code>(i-1, j)</code> 或 <code>(i, j-1)</code> 位置中选择一个较大的珠宝总价值，加上当前位置的珠宝价值 <code>frame[i][j]</code>，得到 <code>dp[i][j]</code> 的值。</li>\n</ul>\n</li>\n</ul>\n<h4>3. <strong>边界条件</strong>：</h4>\n<ul>\n<li><strong>第一行</strong>：只能从左边过来，所以 <code>dp[0][j]</code> 只能通过加上前一列的值得到： <img loading=\"lazy\" src=\"file:///C:\\Users\\22501\\AppData\\Local\\Temp\\QQ_1723250945377.png\" data-is-external-image=\"true\"></li>\n<li><strong>第一列</strong>：只能从上边过来，所以 <code>dp[i][0]</code> 只能通过加上前一行的值得到： <span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\">dp[i]<img loading=\"lazy\" src=\"file:///C:\\Users\\22501\\AppData\\Local\\Temp\\QQ_1723250957613.png\" data-is-external-image=\"true\"></span></span></span></li>\n<li><strong>起点</strong>：<code>dp[0][0]</code> 就是起点的珠宝价值 <code>frame[0][0]</code>。</li>\n</ul>\n<h4>4. <strong>求解最终结果</strong>：</h4>\n<ul>\n<li>当我们填满整个 <code>dp</code> 矩阵后，右下角的 <code>dp[m-1][n-1]</code> 就是从左上角到右下角的最大珠宝价值。</li>\n</ul>\n<h3>例子解析</h3>\n<p>假设 <code>frame</code> 为：</p>\n<table style=\"border-collapse: collapse; width: 40.7412%; height: 150.508px;\" border=\"1\">\n<tbody>\n<tr style=\"height: 50.1693px;\">\n<td style=\"width: 33.5074%; height: 50.1693px;\">1</td>\n<td style=\"width: 33.5074%; height: 50.1693px;\">3</td>\n<td style=\"width: 33.2234%; height: 50.1693px;\">1</td>\n</tr>\n<tr style=\"height: 50.1693px;\">\n<td style=\"width: 33.5074%; height: 50.1693px;\">1</td>\n<td style=\"width: 33.5074%; height: 50.1693px;\">5</td>\n<td style=\"width: 33.2234%; height: 50.1693px;\">1</td>\n</tr>\n<tr style=\"height: 50.1693px;\">\n<td style=\"width: 33.5074%; height: 50.1693px;\">4</td>\n<td style=\"width: 33.5074%; height: 50.1693px;\">2</td>\n<td style=\"width: 33.2234%; height: 50.1693px;\">1</td>\n</tr>\n</tbody>\n</table>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist-s\">​​​</span></span></span></span></span></span></span></span></span></span></p>\n<ul>\n<li><strong>初始状态</strong>：\n<ul>\n<li><code>dp[0][0] = 1</code> （起点值为1）</li>\n</ul>\n</li>\n<li><strong>第一行</strong>：\n<ul>\n<li><code>dp[0][1] = dp[0][0] + 3 = 4</code></li>\n<li><code>dp[0][2] = dp[0][1] + 1 = 5</code></li>\n</ul>\n</li>\n<li><strong>第一列</strong>：\n<ul>\n<li><code>dp[1][0] = dp[0][0] + 1 = 2</code></li>\n<li><code>dp[2][0] = dp[1][0] + 4 = 6</code></li>\n</ul>\n</li>\n<li><strong>填充剩余表格</strong>：\n<ul>\n<li><code>dp[1][1] = frame[1][1] + max(dp[0][1], dp[1][0]) = 5 + max(4, 2) = 9</code></li>\n<li><code>dp[1][2] = frame[1][2] + max(dp[0][2], dp[1][1]) = 1 + max(5, 9) = 10</code></li>\n<li><code>dp[2][1] = frame[2][1] + max(dp[1][1], dp[2][0]) = 2 + max(9, 6) = 11</code></li>\n<li><code>dp[2][2] = frame[2][2] + max(dp[1][2], dp[2][1]) = 1 + max(10, 11) = 12</code></li>\n</ul>\n</li>\n</ul>\n<p>最终得到 <code>dp[2][2] = 12</code>，即从左上角到右下角路径上的最大珠宝价值是 12。</p>\n<h3>总结</h3>\n<p>通过这种方法，我们能有效计算出在给定规则下能拿到的最大珠宝价值，时间复杂度为 <code>O(m * n)</code>。</p>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T08:49:40+08:00",
            "date_modified": "2024-08-10T08:49:40+08:00"
        }
    ]
}
