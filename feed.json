{
    "version": "https://jsonfeed.org/version/1",
    "title": "白衫如初",
    "description": "",
    "home_page_url": "https://hxfcoy.github.io/xcll.github.io",
    "feed_url": "https://hxfcoy.github.io/xcll.github.io/feed.json",
    "user_comment": "",
    "icon": "https://hxfcoy.github.io/xcll.github.io/media/website/LOGO.4a06cdd2.png",
    "author": {
        "name": "fcoy"
    },
    "items": [
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/15-san-shu-zhi-he.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/15-san-shu-zhi-he.html",
            "title": "15. 三数之和",
            "content_html": "<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1i4u8qoul21\">实现代码</a></li>\n<li><a href=\"#mcetoc_1i4u8jjga1r\">解释</a>\n<ul>\n<li><a href=\"#mcetoc_1i4u8jjga1s\">时间复杂度</a></li>\n<li><a href=\"#mcetoc_1i4u8jjga1t\">空间复杂度</a></li>\n</ul>\n</li>\n<li><a href=\"#mcetoc_1i4u8jjga1u\">cmp解释</a>\n<ul>\n<li><a href=\"#mcetoc_1i4u8jjga1v\">返回值的含义</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n<p> </p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n<strong>解释：</strong>\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [0,1,1]\n<strong>输出：</strong>[]\n<strong>解释：</strong>唯一可能的三元组和不为 0 。\n</pre>\n<p><strong>示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>[[0,0,0]]\n<strong>解释：</strong>唯一可能的三元组和为 0 。</pre>\n<h3 id=\"mcetoc_1i4u8qoul21\">实现代码</h3>\n<pre class=\"language-c\"><code>int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    int cmp(const void* a, const void* b) {\n    return *(int*)a - *(int*)b;\n}\n    *returnSize = 0;\n    if (numsSize &lt; 3) {\n        return NULL;\n    }\n\n    // 先对数组排序\n    qsort(nums, numsSize, sizeof(int), cmp);\n\n    int** result = (int**)malloc(numsSize * numsSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(numsSize * numsSize * sizeof(int));\n\n    for (int i = 0; i &lt; numsSize - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue; // 跳过重复的元素\n        }\n\n        int left = i + 1;\n        int right = numsSize - 1;\n\n        while (left &lt; right) {\n            int sum = nums[i] + nums[left] + nums[right];\n\n            if (sum == 0) {\n                // 找到一组符合条件的三元组\n                result[*returnSize] = (int*)malloc(3 * sizeof(int));\n                result[*returnSize][0] = nums[i];\n                result[*returnSize][1] = nums[left];\n                result[*returnSize][2] = nums[right];\n                (*returnColumnSizes)[*returnSize] = 3;\n                (*returnSize)++;\n\n                // 移动指针并跳过重复的元素\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n\n                left++;\n                right--;\n            } else if (sum &lt; 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n\n    return result;\n}</code></pre>\n<h3 id=\"mcetoc_1i4u8jjga1r\">解释</h3>\n<ol>\n<li>\n<p><strong>排序</strong>：我们首先对数组进行排序，这样可以更容易地避免重复的三元组，同时可以利用排序后的数组进行双指针的查找。</p>\n</li>\n<li>\n<p><strong>双指针查找</strong>：</p>\n<ul>\n<li>固定一个数 <code>nums[i]</code>，然后使用双指针在 <code>nums[i+1]</code> 到 <code>nums[numsSize-1]</code> 之间寻找两个数使得三数之和为0。</li>\n<li>如果找到满足条件的三元组，加入结果集，然后移动双指针，同时跳过重复的元素。</li>\n</ul>\n</li>\n<li>\n<p><strong>跳过重复</strong>：在外层循环和双指针循环中，如果发现当前元素与上一个元素相同，则跳过，避免重复三元组的出现。</p>\n</li>\n<li>\n<p><strong>返回结果</strong>：</p>\n<ul>\n<li><code>returnSize</code>：表示返回的三元组的个数。</li>\n<li><code>returnColumnSizes</code>：表示每个三元组的大小（都是3）。</li>\n<li>返回的 <code>result</code> 是一个二维数组，包含所有符合条件的三元组。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"mcetoc_1i4u8jjga1s\">时间复杂度</h4>\n<ul>\n<li><strong>排序</strong>的时间复杂度是 <code>O(n log n)</code>。</li>\n<li>外层循环和内层双指针循环的复杂度是 <code>O(n^2)</code>。</li>\n</ul>\n<p>因此，整体的时间复杂度为 <code>O(n^2)</code>。</p>\n<h4 id=\"mcetoc_1i4u8jjga1t\">空间复杂度</h4>\n<ul>\n<li>主要用于存储结果的二维数组，最坏情况下需要 <code>O(n^2)</code> 的空间。</li>\n</ul>\n<h3 id=\"mcetoc_1i4u8jjga1u\">cmp解释</h3>\n<pre class=\"language-c\"><code>int cmp(const void* a, const void* b) {\n    return *(int*)a - *(int*)b;\n}</code></pre>\n<ul>\n<li>\n<p><code>*(int*)a</code>：这个表达式首先将 <code>void*</code> 类型的指针 <code>a</code> 转换为 <code>int*</code> 类型的指针，然后通过 <code>*</code> 操作符解引用，获取该内存位置存储的整数值。</p>\n</li>\n<li>\n<p><code>*(int*)b</code>：同样地，将 <code>void*</code> 类型的指针 <code>b</code> 转换为 <code>int*</code> 类型的指针，然后解引用获取整数值。</p>\n</li>\n<li>\n<p><code>*(int*)a - *(int*)b</code>：通过相减，比较这两个整数的大小。</p>\n</li>\n</ul>\n<h4 id=\"mcetoc_1i4u8jjga1v\">返回值的含义</h4>\n<ul>\n<li>如果 <code>*(int*)a</code> 比 <code>*(int*)b</code> 小，则返回一个负数。这表示在排序过程中，<code>a</code> 应该排在 <code>b</code> 之前。</li>\n<li>如果 <code>*(int*)a</code> 比 <code>*(int*)b</code> 大，则返回一个正数，表示 <code>a</code> 应该排在 <code>b</code> 之后。</li>\n<li>如果 <code>*(int*)a</code> 和 <code>*(int*)b</code> 相等，则返回 0，表示它们在排序中的位置相同。</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T21:38:37+08:00",
            "date_modified": "2024-08-10T21:49:47+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/2582-di-zhen-tou.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/2582-di-zhen-tou.html",
            "title": "2582. 递枕头",
            "content_html": "<p><code>n</code> 个人站成一排，按从 <code>1</code> 到 <code>n</code> 编号。最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。</p>\n<ul>\n<li>例如，当枕头到达第 <code>n</code> 个人时，TA 会将枕头传递给第 <code>n - 1</code> 个人，然后传递给第 <code>n - 2</code> 个人，依此类推。</li>\n</ul>\n<p>给你两个正整数 <code>n</code> 和 <code>time</code> ，返回 <code>time</code> 秒后拿着枕头的人的编号。</p>\n<p> </p>\n<p><strong>示例 1：</strong></p>\n<pre><strong>输入：</strong>n = 4, time = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 3 -&gt; 2 。\n5 秒后，枕头传递到第 2 个人手中。\n</pre>\n<p><strong>示例 2：</strong></p>\n<pre><strong>输入：</strong>n = 3, time = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 。\n2 秒后，枕头传递到第 3 个人手中。</pre>\n<pre class=\"language-c\"><code>int passThePillow(int n, int time) {\n    // 如果time对(n-1)取模，则time % (n-1) 表示经过几个完整的正向传递后的余数\n    // 通过方向(正向或反向)计算最终位置\n    int cycle = time / (n - 1);\n    int remainder = time % (n - 1);\n\n    // 如果cycle是偶数，枕头在正向传递，位置为 1 + remainder\n    // 如果cycle是奇数，枕头在反向传递，位置为 n - remainder\n    if (cycle % 2 == 0) {\n        return 1 + remainder;\n    } else {\n        return n - remainder;\n    }\n}</code></pre>\n<ul>\n<li>\n<p><strong>循环次数</strong>：枕头传递方向的改变仅在到达队首或队尾时发生。如果将一个完整的往返（从第1个人传递到第n个人再回到第1个人）视为一个循环，枕头在经过一个完整的循环后又回到了初始位置。</p>\n</li>\n<li>\n<p><strong>方向和位置计算</strong>：</p>\n<ul>\n<li>假设当前方向为正向（从第1个人向第n个人传递），则枕头每秒传递到下一个人。</li>\n<li>一旦到达第n个人，方向就会反向，接下来每秒传递给前一个人。</li>\n</ul>\n</li>\n<li>\n<p><strong>计算逻辑</strong>：</p>\n<ul>\n<li>如果 <code>time</code> 的值加上初始位置是在第一个方向的范围内，则只需直接计算出具体位置。</li>\n<li>如果在反方向范围内，也能通过简单的计算得到。</li>\n</ul>\n</li>\n</ul>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T21:30:43+08:00",
            "date_modified": "2024-08-10T21:30:43+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/lcr-166-zhu-bao-de-zui-gao-jie-zhi.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/lcr-166-zhu-bao-de-zui-gao-jie-zhi.html",
            "title": "LCR 166. 珠宝的最高价值",
            "content_html": "<p>现有一个记作二维矩阵 <code>frame</code> 的珠宝架，其中 <code>frame[i][j]</code> 为该位置珠宝的价值。拿取珠宝的规则为：</p>\n<ul>\n<li>只能从架子的左上角开始拿珠宝</li>\n<li>每次可以移动到右侧或下侧的相邻位置</li>\n<li>到达珠宝架子的右下角时，停止拿取</li>\n</ul>\n<p>注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 <code>frame = [[0]]</code>。</p>\n<p> </p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入:</strong> frame = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>输出:</strong> <code>12\n</code><strong>解释:</strong> 路径 1→3→5→2→1 可以拿到最高价值的珠宝</pre>\n<pre class=\"language-apacheconf\"><code>int jewelleryValue(int** frame, int frameSize, int* frameColSize) {\n    if (frameSize == 0 || frameColSize[0] == 0) {\n        return 0; // 处理空架子的情况\n    }\n\n    int dp[frameSize][frameColSize[0]];\n\n    // 初始化 dp 数组\n    dp[0][0] = frame[0][0];\n\n    // 初始化第一列\n    for (int i = 1; i &lt; frameSize; i++) {\n        dp[i][0] = dp[i-1][0] + frame[i][0];\n    }\n\n    // 初始化第一行\n    for (int j = 1; j &lt; frameColSize[0]; j++) {\n        dp[0][j] = dp[0][j-1] + frame[0][j];\n    }\n\n    // 填充剩余的 dp 表格\n    for (int i = 1; i &lt; frameSize; i++) {\n        for (int j = 1; j &lt; frameColSize[0]; j++) {\n            dp[i][j] = frame[i][j] + (dp[i-1][j] &gt; dp[i][j-1] ? dp[i-1][j] : dp[i][j-1]);\n        }\n    }\n\n    // 返回右下角的最大值\n    return dp[frameSize-1][frameColSize[0]-1];\n}\n</code></pre>\n<h3>动态规划思想</h3>\n<p>动态规划的核心思想是通过记录子问题的解来避免重复计算。我们用一个二维数组 <code>dp</code> 来存储从左上角到某个位置的最大珠宝总价值。</p>\n<h4>1. <strong>定义状态</strong>：</h4>\n<ul>\n<li>设 <code>dp[i][j]</code> 表示从左上角 <code>(0, 0)</code> 到位置 <code>(i, j)</code> 的最大珠宝价值。</li>\n</ul>\n<h4>2. <strong>状态转移方程</strong>：</h4>\n<ul>\n<li>由于只能向右或向下移动，所以 <code>dp[i][j]</code> 可以从左侧的 <code>dp[i][j-1]</code> 或上方的 <code>dp[i-1][j]</code> 位置到达。因此，状态转移方程为： <img loading=\"lazy\" src=\"file:///C:\\Users\\22501\\AppData\\Local\\Temp\\QQ_1723250937888.png\" data-is-external-image=\"true\">\n<ul>\n<li>这表示从 <code>(i-1, j)</code> 或 <code>(i, j-1)</code> 位置中选择一个较大的珠宝总价值，加上当前位置的珠宝价值 <code>frame[i][j]</code>，得到 <code>dp[i][j]</code> 的值。</li>\n</ul>\n</li>\n</ul>\n<h4>3. <strong>边界条件</strong>：</h4>\n<ul>\n<li><strong>第一行</strong>：只能从左边过来，所以 <code>dp[0][j]</code> 只能通过加上前一列的值得到： <img loading=\"lazy\" src=\"file:///C:\\Users\\22501\\AppData\\Local\\Temp\\QQ_1723250945377.png\" data-is-external-image=\"true\"></li>\n<li><strong>第一列</strong>：只能从上边过来，所以 <code>dp[i][0]</code> 只能通过加上前一行的值得到： <span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\">dp[i]<img loading=\"lazy\" src=\"file:///C:\\Users\\22501\\AppData\\Local\\Temp\\QQ_1723250957613.png\" data-is-external-image=\"true\"></span></span></span></li>\n<li><strong>起点</strong>：<code>dp[0][0]</code> 就是起点的珠宝价值 <code>frame[0][0]</code>。</li>\n</ul>\n<h4>4. <strong>求解最终结果</strong>：</h4>\n<ul>\n<li>当我们填满整个 <code>dp</code> 矩阵后，右下角的 <code>dp[m-1][n-1]</code> 就是从左上角到右下角的最大珠宝价值。</li>\n</ul>\n<h3>例子解析</h3>\n<p>假设 <code>frame</code> 为：</p>\n<table style=\"border-collapse: collapse; width: 40.7412%; height: 150.508px;\" border=\"1\">\n<tbody>\n<tr style=\"height: 50.1693px;\">\n<td style=\"width: 33.5074%; height: 50.1693px;\">1</td>\n<td style=\"width: 33.5074%; height: 50.1693px;\">3</td>\n<td style=\"width: 33.2234%; height: 50.1693px;\">1</td>\n</tr>\n<tr style=\"height: 50.1693px;\">\n<td style=\"width: 33.5074%; height: 50.1693px;\">1</td>\n<td style=\"width: 33.5074%; height: 50.1693px;\">5</td>\n<td style=\"width: 33.2234%; height: 50.1693px;\">1</td>\n</tr>\n<tr style=\"height: 50.1693px;\">\n<td style=\"width: 33.5074%; height: 50.1693px;\">4</td>\n<td style=\"width: 33.5074%; height: 50.1693px;\">2</td>\n<td style=\"width: 33.2234%; height: 50.1693px;\">1</td>\n</tr>\n</tbody>\n</table>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist-s\">​​​</span></span></span></span></span></span></span></span></span></span></p>\n<ul>\n<li><strong>初始状态</strong>：\n<ul>\n<li><code>dp[0][0] = 1</code> （起点值为1）</li>\n</ul>\n</li>\n<li><strong>第一行</strong>：\n<ul>\n<li><code>dp[0][1] = dp[0][0] + 3 = 4</code></li>\n<li><code>dp[0][2] = dp[0][1] + 1 = 5</code></li>\n</ul>\n</li>\n<li><strong>第一列</strong>：\n<ul>\n<li><code>dp[1][0] = dp[0][0] + 1 = 2</code></li>\n<li><code>dp[2][0] = dp[1][0] + 4 = 6</code></li>\n</ul>\n</li>\n<li><strong>填充剩余表格</strong>：\n<ul>\n<li><code>dp[1][1] = frame[1][1] + max(dp[0][1], dp[1][0]) = 5 + max(4, 2) = 9</code></li>\n<li><code>dp[1][2] = frame[1][2] + max(dp[0][2], dp[1][1]) = 1 + max(5, 9) = 10</code></li>\n<li><code>dp[2][1] = frame[2][1] + max(dp[1][1], dp[2][0]) = 2 + max(9, 6) = 11</code></li>\n<li><code>dp[2][2] = frame[2][2] + max(dp[1][2], dp[2][1]) = 1 + max(10, 11) = 12</code></li>\n</ul>\n</li>\n</ul>\n<p>最终得到 <code>dp[2][2] = 12</code>，即从左上角到右下角路径上的最大珠宝价值是 12。</p>\n<h3>总结</h3>\n<p>通过这种方法，我们能有效计算出在给定规则下能拿到的最大珠宝价值，时间复杂度为 <code>O(m * n)</code>。</p>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T08:49:40+08:00",
            "date_modified": "2024-08-10T08:49:40+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/ruan-jian.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/ruan-jian.html",
            "title": "资源",
            "content_html": "<p>QQNT 插件加载器<a href=\"https://github.com/LiteLoaderQQNT/LiteLoaderQQNT\">LiteLoaderQQNT</a></p>\n<p>基于QQ的全自动签到模块<a href=\"https://github.com/LuckyPray/XAutoDaily\">XAutoDaily</a></p>\n<p>QQXposed 模块<a href=\"https://github.com/cinit/QAuxiliary\">QAuxiliary</a></p>\n<p><a href=\"https://github.com/clash-verge-rev/clash-verge-rev\">clash-verge-rev</a></p>\n<p>蔚蓝档案自动化<a href=\"https://github.com/pur1fying/blue_archive_auto_script\">baas</a></p>\n<p>Bili动态抽奖助手<a href=\"https://github.com/shanmiteko/LotteryAutoScript\">LotteryAutoScript</a></p>\n<p><a href=\"https://www.cycanime.com/\">次元城动漫</a>（有弹幕，没啥广告，挺好用的）</p>\n<p><a href=\"https://www.touchgal.co/\">TouchGAL</a>-一站式Galgame文化社区！</p>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
            ],
            "date_published": "2024-08-10T08:00:21+08:00",
            "date_modified": "2024-08-10T18:34:11+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/steamyou-xi.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/steamyou-xi.html",
            "title": "Steam游戏",
            "content_html": "<p><a href=\"https://steamcommunity.com/profiles/76561199206989349/\">我的steam😀</a></p>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "游戏"
            ],
            "date_published": "2024-08-10T07:35:01+08:00",
            "date_modified": "2024-08-10T07:35:01+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan.html",
            "title": "3. 无重复字符的最长子串",
            "content_html": "<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 </strong><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">子串</span><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">的长度。</span></p>\n<p> </p>\n<p><strong>示例 1:</strong></p>\n<pre><strong>输入: </strong>s = \"abcabcbb\"\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>\"abc\"</code>，所以其长度为 3。</pre>\n<p><strong>示例 2:</strong></p>\n<pre><strong>输入: </strong>s = \"bbbbb\"\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\"b\"</code>，所以其长度为 1。</pre>\n<p><strong>示例 3:</strong></p>\n<pre><strong>输入: </strong>s = \"pwwkew\"\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\"wke\"</code>，所以其长度为 3。   请注意，你的答案必须是 <strong>子串 </strong>的长度，<code style=\"font-size: 0.790123em; font-weight: var(--font-weight-normal); font-family: var(--font-monospace); background-image: none;\">\"pwke\"</code><span style=\"background-color: var(--gray-1); font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);\"> 是一个</span><em style=\"font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);\">子序列，</em><span style=\"background-color: var(--gray-1); font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);\">不是子串。</span></pre>\n<pre class=\"language-c\"><code>int lengthOfLongestSubstring(char* s) {\n    int n = strlen(s);\n    if (n == 0) return 0;\n    \n    int maxLength = 0;\n    int start = 0;\n    int charIndex[128];  // ASCII 字符总数为128\n    \n    // 初始化charIndex数组，-1表示未出现过\n    for (int i = 0; i &lt; 128; i++) {\n        charIndex[i] = -1;\n    }\n    \n    for (int end = 0; end &lt; n; end++) {\n        char currentChar = s[end];\n        // 如果当前字符之前已经在窗口中出现过，移动start指针\n        if (charIndex[currentChar] &gt;= start) {\n            start = charIndex[currentChar] + 1;\n        }\n        \n        // 更新字符的最新出现位置\n        charIndex[currentChar] = end;\n        \n        // 更新最大长度\n        int currentLength = end - start + 1;\n        if (currentLength &gt; maxLength) {\n            maxLength = currentLength;\n        }\n    }\n    \n    return maxLength;\n}</code></pre>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T07:17:31+08:00",
            "date_modified": "2024-08-10T07:18:05+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/2-liang-shu-xiang-jia.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/2-liang-shu-xiang-jia.html",
            "title": "2. 两数相加",
            "content_html": "<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p> </p>\n<p><strong class=\"example\">示例 1：</strong></p>\n<p><img loading=\"lazy\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg\" alt=\"\" data-is-external-image=\"true\"></p>\n<pre><strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[7,0,8]\n<strong>解释：</strong>342 + 465 = 807.\n</pre>\n<p><strong class=\"example\">示例 2：</strong></p>\n<pre><strong>输入：</strong>l1 = [0], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n<p><strong class=\"example\">示例 3：</strong></p>\n<pre><strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>输出：</strong>[8,9,9,9,0,0,0,1]</pre>\n<p> </p>\n<pre class=\"language-c\"><code>struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode dummy;\n    dummy.next = NULL;\n    struct ListNode* current = &amp;dummy;\n    int carry = 0;\n\n    // 遍历两个链表，直到所有的节点处理完毕\n    while (l1 != NULL || l2 != NULL) {\n        // 获取当前节点的值，如果当前链表结束则用0代替\n        int val1 = (l1 != NULL) ? l1-&gt;val : 0;\n        int val2 = (l2 != NULL) ? l2-&gt;val : 0;\n        \n        // 计算当前位的和以及进位\n        int total = val1 + val2 + carry;\n        carry = total / 10;\n        int currentSum = total % 10;\n        \n        // 将计算的当前位加入结果链表\n        current-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));\n        current-&gt;next-&gt;val = currentSum;\n        current-&gt;next-&gt;next = NULL;\n        current = current-&gt;next;\n        \n        // 移动指针\n        if (l1 != NULL) l1 = l1-&gt;next;\n        if (l2 != NULL) l2 = l2-&gt;next;\n    }\n    \n    // 如果最后有进位，添加一个新的节点\n    if (carry &gt; 0) {\n        current-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));\n        current-&gt;next-&gt;val = carry;\n        current-&gt;next-&gt;next = NULL;\n    }\n    \n    // 返回结果链表的头结点\n    return dummy.next;\n}</code></pre>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T07:14:36+08:00",
            "date_modified": "2024-08-10T07:14:36+08:00"
        },
        {
            "id": "https://hxfcoy.github.io/xcll.github.io/1-liang-shu-zhi-he.html",
            "url": "https://hxfcoy.github.io/xcll.github.io/1-liang-shu-zhi-he.html",
            "title": "1. 两数之和",
            "content_html": "<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n<p>你可以按任意顺序返回答案。</p>\n<p> </p>\n<p><strong class=\"example\">示例 1：</strong></p>\n<pre><strong>输入：</strong>nums = [2,7,11,15], target = 9\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n</pre>\n<p><strong class=\"example\">示例 2：</strong></p>\n<pre><strong>输入：</strong>nums = [3,2,4], target = 6\n<strong>输出：</strong>[1,2]\n</pre>\n<p><strong class=\"example\">示例 3：</strong></p>\n<pre><strong>输入：</strong>nums = [3,3], target = 6\n<strong>输出：</strong>[0,1]<code style=\"font-weight: var(--font-weight-normal);\"></code><code></code></pre>\n<pre class=\"language-c\"><code>int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n\n    // 用于存储结果的数组\n    int *result = (int *)malloc(2 * sizeof(int));\n    *returnSize = 2; // 结果数组的大小是2\n    // 遍历数组，寻找和为target的两个数\n    for (int i = 0; i &lt; numsSize; i++) {\n        for (int j = i + 1; j &lt; numsSize; j++) {\n            // 如果找到，返回它们的下标\n            if (nums[i] + nums[j] == target) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n        }\n    }\n    // 如果未找到，返回NULL\n    *returnSize = 0;\n    return NULL;\n}</code></pre>",
            "author": {
                "name": "fcoy"
            },
            "tags": [
                   "力扣"
            ],
            "date_published": "2024-08-10T07:10:58+08:00",
            "date_modified": "2024-08-10T07:15:36+08:00"
        }
    ]
}
