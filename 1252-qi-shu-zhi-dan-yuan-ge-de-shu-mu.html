<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>1252. 奇数值单元格的数目 - xcll’s blog</title><meta name="robots" content="noindex,nofollow"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="stylesheet" href="https://hxfcoy.github.io/xcll.github.io/media/plugins/syntaxHighlighter/prism-beige.css"><link rel="alternate" type="application/atom+xml" href="https://hxfcoy.github.io/xcll.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://hxfcoy.github.io/xcll.github.io/feed.json"><link rel="stylesheet" href="https://hxfcoy.github.io/xcll.github.io/assets/css/style.css?v=48ae57c9831f7efa1e623ac4eb92d438"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://hxfcoy.github.io/xcll.github.io/1252-qi-shu-zhi-dan-yuan-ge-de-shu-mu.html"},"headline":"1252. 奇数值单元格的数目","datePublished":"2024-08-18T07:57","dateModified":"2024-08-18T07:57","image":{"@type":"ImageObject","url":"https://hxfcoy.github.io/xcll.github.io/media/website/image-removebg-preview.png","height":167,"width":582},"description":"","author":{"@type":"Person","name":"fcoy","url":"https://hxfcoy.github.io/xcll.github.io/authors/fcoy/"},"publisher":{"@type":"Organization","name":"fcoy","logo":{"@type":"ImageObject","url":"https://hxfcoy.github.io/xcll.github.io/media/website/image-removebg-preview.png","height":167,"width":582}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://hxfcoy.github.io/xcll.github.io/"><img src="https://hxfcoy.github.io/xcll.github.io/media/website/image-removebg-preview.png" alt="xcll’s blog" width="582" height="167"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://hxfcoy.github.io/xcll.github.io/tags/li-kou/" target="_self">力扣</a></li><li><a href="https://hxfcoy.github.io/xcll.github.io/tags/you-xi/" target="_self">游戏</a></li><li><a href="https://hxfcoy.github.io/xcll.github.io/ruan-jian.html" target="_self">资源</a></li></ul></nav></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://hxfcoy.github.io/xcll.github.io/media/website/BA2.jpg" srcset="https://hxfcoy.github.io/xcll.github.io/media/website/responsive/BA2-xs.jpg 300w, https://hxfcoy.github.io/xcll.github.io/media/website/responsive/BA2-sm.jpg 480w, https://hxfcoy.github.io/xcll.github.io/media/website/responsive/BA2-md.jpg 768w, https://hxfcoy.github.io/xcll.github.io/media/website/responsive/BA2-lg.jpg 1024w, https://hxfcoy.github.io/xcll.github.io/media/website/responsive/BA2-xl.jpg 1360w, https://hxfcoy.github.io/xcll.github.io/media/website/responsive/BA2-2xl.jpg 1600w" sizes="100vw" loading="eager" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2024-08-18T07:57">八月 18, 2024</time></div><h1>1252. 奇数值单元格的数目</h1><div class="post__meta post__meta--author"><a href="https://hxfcoy.github.io/xcll.github.io/authors/fcoy/" class="feed__author">fcoy</a></div></div></header></div><div class="wrapper post__entry"><div class="post__toc"><h3>目录</h3><ul><li><a href="#mcetoc_1i5hcdbnu1h">题目</a></li><li><a href="#mcetoc_1i5hcdbnu1i">代码</a></li><li><a href="#mcetoc_1i5hcdbnu1j">代码说明</a></li><li><a href="#mcetoc_1i5hcdbnu1k">参数说明</a></li></ul></div><h3 id="mcetoc_1i5hcdbnu1h">题目</h3><p>给你一个 <code>m x n</code> 的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p><p>另有一个二维索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 指向矩阵中的某个位置，其中 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（<strong>从 <code>0</code> 开始编号</strong>）。</p><p>对 <code>indices[i]</code> 所指向的每个位置，应同时执行下述增量操作：</p><ol><li><code>r<sub>i</sub></code> 行上的所有单元格，加 <code>1</code> 。</li><li><code>c<sub>i</sub></code> 列上的所有单元格，加 <code>1</code> 。</li></ol><p>给你 <code>m</code>、<code>n</code> 和 <code>indices</code> 。请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 <strong>奇数值单元格</strong> 的数目。</p><p> </p><p><strong>示例 1：</strong></p><p><img loading="lazy" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png" alt="" data-is-external-image="true"></p><pre><strong>输入：</strong>m = 2, n = 3, indices = [[0,1],[1,1]]
<strong>输出：</strong>6
<strong>解释：</strong>最开始的矩阵是 [[0,0,0],[0,0,0]]。
第一次增量操作后得到 [[1,2,1],[0,1,0]]。
最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。
</pre><p><strong>示例 2：</strong></p><p><img loading="lazy" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png" alt="" data-is-external-image="true"></p><pre><strong>输入：</strong>m = 2, n = 2, indices = [[1,1],[0,0]]
<strong>输出：</strong>0
<strong>解释：</strong>最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。</pre><h3 id="mcetoc_1i5hcdbnu1i">代码</h3><pre class="language-c line-numbers"><code>int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize) {
    // 初始化行和列的增量计数
    int* row_count = (int*)calloc(m, sizeof(int));
    int* col_count = (int*)calloc(n, sizeof(int));
    
    // 对每个 indices 中的 (ri, ci) 进行操作
    for (int i = 0; i &lt; indicesSize; i++) {
        int ri = indices[i][0];
        int ci = indices[i][1];
        row_count[ri]++;
        col_count[ci]++;
    }
    
    // 计算奇数值单元格的数量
    int odd_count = 0;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            // 计算当前单元格的值
            int value = row_count[i] + col_count[j];
            if (value % 2 == 1) {
                odd_count++;
            }
        }
    }
    
    // 释放动态分配的内存
    free(row_count);
    free(col_count);
    
    return odd_count;
}</code></pre><h3 id="mcetoc_1i5hcdbnu1j">代码说明</h3><ol><li><strong>内存分配</strong>：使用 <code>calloc</code> 分别为 <code>row_count</code> 和 <code>col_count</code> 动态分配内存，并将其初始值设置为 0。</li><li><strong>操作增量</strong>：对每个索引 <code>[ri, ci]</code>，增加对应行和列的计数。</li><li><strong>计算奇数单元格</strong>：通过遍历每个单元格，计算其对应的行列增量和，如果结果是奇数，增加计数。</li><li><strong>释放内存</strong>：最后使用 <code>free</code> 释放动态分配的内存。</li></ol><h3 id="mcetoc_1i5hcdbnu1k">参数说明</h3><ul><li><code>m</code>：矩阵的行数。</li><li><code>n</code>：矩阵的列数。</li><li><code>indices</code>：二维索引数组。</li><li><code>indicesSize</code>：<code>indices</code> 数组的行数（即索引对的数量）。</li><li><code>indicesColSize</code>：每一行索引数组的列数（始终为 2）。</li></ul></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 八月 18, 2024</p><ul class="post__tag"><li><a href="https://hxfcoy.github.io/xcll.github.io/tags/li-kou/">力扣</a></li></ul><div class="post__share"></div><div class="post__bio bio"><div><h3 class="bio__name"><a href="https://hxfcoy.github.io/xcll.github.io/authors/fcoy/" rel="author">fcoy</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://hxfcoy.github.io/xcll.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://hxfcoy.github.io/xcll.github.io/819-zui-chang-jian-de-dan-ci.html" class="post__nav-link" rel="prev"><span>Previous</span> 819. 最常见的单词</a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p class="align-center">浮云一别后，流水十年间。</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://hxfcoy.github.io/xcll.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="https://hxfcoy.github.io/xcll.github.io/assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script src="https://hxfcoy.github.io/xcll.github.io/media/plugins/pageprefetching/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
					quicklink.listen({
						prerender: true,
						el: document.querySelector('body'),
						delay: 0,
						limit: Infinity,
						throttle: Infinity,
						timeout: 2000
					});
				});</script><script defer="defer" src="https://hxfcoy.github.io/xcll.github.io/media/plugins/syntaxHighlighter/prism.js"></script><script defer="defer" src="https://hxfcoy.github.io/xcll.github.io/media/plugins/syntaxHighlighter/prism-line-numbers.min.js"></script><script defer="defer" src="https://hxfcoy.github.io/xcll.github.io/media/plugins/syntaxHighlighter/clipboard.min.js"></script><script defer="defer" src="https://hxfcoy.github.io/xcll.github.io/media/plugins/syntaxHighlighter/prism-copy-to-clipboard.min.js"></script><script defer="defer" src="https://hxfcoy.github.io/xcll.github.io/media/plugins/syntaxHighlighter/prism-show-invisibles.min.js"></script></body></html>