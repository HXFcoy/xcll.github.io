<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>xcll’s blog</title>
    <link href="https://hxfcoy.github.io/xcll.github.io/feed.xml" rel="self" />
    <link href="https://hxfcoy.github.io/xcll.github.io" />
    <updated>2024-08-18T07:57:58+08:00</updated>
    <author>
        <name>fcoy</name>
    </author>
    <id>https://hxfcoy.github.io/xcll.github.io</id>

    <entry>
        <title>1252. 奇数值单元格的数目</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/1252-qi-shu-zhi-dan-yuan-ge-de-shu-mu.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/1252-qi-shu-zhi-dan-yuan-ge-de-shu-mu.html</id>
            <category term="力扣"/>

        <updated>2024-08-18T07:57:58+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i5hcdbnu1h">题目</a></li>
<li><a href="#mcetoc_1i5hcdbnu1i">代码</a></li>
<li><a href="#mcetoc_1i5hcdbnu1j">代码说明</a></li>
<li><a href="#mcetoc_1i5hcdbnu1k">参数说明</a></li>
</ul>
</div>
<h3 id="mcetoc_1i5hcdbnu1h">题目</h3>
<p>给你一个 <code>m x n</code> 的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p>
<p>另有一个二维索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 指向矩阵中的某个位置，其中 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（<strong>从 <code>0</code> 开始编号</strong>）。</p>
<p>对 <code>indices[i]</code> 所指向的每个位置，应同时执行下述增量操作：</p>
<ol>
<li><code>r<sub>i</sub></code> 行上的所有单元格，加 <code>1</code> 。</li>
<li><code>c<sub>i</sub></code> 列上的所有单元格，加 <code>1</code> 。</li>
</ol>
<p>给你 <code>m</code>、<code>n</code> 和 <code>indices</code> 。请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 <strong>奇数值单元格</strong> 的数目。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img loading="lazy" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png" alt="" data-is-external-image="true"></p>
<pre><strong>输入：</strong>m = 2, n = 3, indices = [[0,1],[1,1]]
<strong>输出：</strong>6
<strong>解释：</strong>最开始的矩阵是 [[0,0,0],[0,0,0]]。
第一次增量操作后得到 [[1,2,1],[0,1,0]]。
最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。
</pre>
<p><strong>示例 2：</strong></p>
<p><img loading="lazy" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png" alt="" data-is-external-image="true"></p>
<pre><strong>输入：</strong>m = 2, n = 2, indices = [[1,1],[0,0]]
<strong>输出：</strong>0
<strong>解释：</strong>最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。</pre>
<h3 id="mcetoc_1i5hcdbnu1i">代码</h3>
<pre class="language-c line-numbers"><code>int oddCells(int m, int n, int** indices, int indicesSize, int* indicesColSize) {
    // 初始化行和列的增量计数
    int* row_count = (int*)calloc(m, sizeof(int));
    int* col_count = (int*)calloc(n, sizeof(int));
    
    // 对每个 indices 中的 (ri, ci) 进行操作
    for (int i = 0; i &lt; indicesSize; i++) {
        int ri = indices[i][0];
        int ci = indices[i][1];
        row_count[ri]++;
        col_count[ci]++;
    }
    
    // 计算奇数值单元格的数量
    int odd_count = 0;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            // 计算当前单元格的值
            int value = row_count[i] + col_count[j];
            if (value % 2 == 1) {
                odd_count++;
            }
        }
    }
    
    // 释放动态分配的内存
    free(row_count);
    free(col_count);
    
    return odd_count;
}</code></pre>
<h3 id="mcetoc_1i5hcdbnu1j">代码说明</h3>
<ol>
<li><strong>内存分配</strong>：使用 <code>calloc</code> 分别为 <code>row_count</code> 和 <code>col_count</code> 动态分配内存，并将其初始值设置为 0。</li>
<li><strong>操作增量</strong>：对每个索引 <code>[ri, ci]</code>，增加对应行和列的计数。</li>
<li><strong>计算奇数单元格</strong>：通过遍历每个单元格，计算其对应的行列增量和，如果结果是奇数，增加计数。</li>
<li><strong>释放内存</strong>：最后使用 <code>free</code> 释放动态分配的内存。</li>
</ol>
<h3 id="mcetoc_1i5hcdbnu1k">参数说明</h3>
<ul>
<li><code>m</code>：矩阵的行数。</li>
<li><code>n</code>：矩阵的列数。</li>
<li><code>indices</code>：二维索引数组。</li>
<li><code>indicesSize</code>：<code>indices</code> 数组的行数（即索引对的数量）。</li>
<li><code>indicesColSize</code>：每一行索引数组的列数（始终为 2）。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>819. 最常见的单词</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/819-zui-chang-jian-de-dan-ci.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/819-zui-chang-jian-de-dan-ci.html</id>
            <category term="力扣"/>

        <updated>2024-08-17T07:28:34+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i5eoag1i11">题目</a></li>
<li><a href="#mcetoc_1i5eoag1i12">代码</a></li>
<li><a href="#mcetoc_1i5eoag1i13">解释</a></li>
</ul>
</div>
<h3 id="mcetoc_1i5eoag1i11">题目</h3>
<p>给你一个字符串 <code>paragraph</code> 和一个表示禁用词的字符串数组 <code>banned</code> ，返回出现频率最高的非禁用词。题目数据 <strong>保证 </strong>至少存在一个非禁用词，且答案<strong> 唯一 </strong>。</p>
<p><code>paragraph</code> 中的单词 <strong>不区分大小写</strong> ，答案应以 <strong>小写 </strong>形式返回。</p>
<p> </p>
<p><strong class="example">示例 1：</strong></p>
<pre><strong>输入：</strong>paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]
<strong>输出：</strong>"ball"
<strong>解释：</strong>
"hit" 出现了 3 次，但它是禁用词。
"ball" 出现了两次（没有其他单词出现这么多次），因此它是段落中出现频率最高的非禁用词。
请注意，段落中的单词不区分大小写，
标点符号会被忽略（即使它们紧挨着单词，如 "ball,"），
并且尽管 "hit" 出现的次数更多，但它不能作为答案，因为它是禁用词。
</pre>
<p><strong class="example">示例 2：</strong></p>
<pre><strong>输入：</strong>paragraph = "a.", banned = []
<strong>输出：</strong>"a"</pre>
<h3 id="mcetoc_1i5eoag1i12">代码</h3>
<pre class="language-c line-numbers"><code>#define MAX_WORD_LEN 100
#define MAX_PARA_LEN 10000

// 函数用于比较哈希表中存储的单词
typedef struct {
    char word[MAX_WORD_LEN];
    int count;
} HashTableEntry;

// 将字符串转换为小写
void toLowerCase(char* str) {
    while (*str) {
        *str = tolower(*str);
        str++;
    }
}

// 检查单词是否在禁用词列表中
int isBanned(char* word, char** banned, int bannedSize) {
    for (int i = 0; i &lt; bannedSize; i++) {
        if (strcmp(word, banned[i]) == 0) {
            return 1;
        }
    }
    return 0;
}

// 从段落中提取下一个单词
char* nextWord(char* paragraph, int* index) {
    static char word[MAX_WORD_LEN];
    int i = 0;

    while (paragraph[*index]) {
        char c = paragraph[*index];
        if (isalpha(c)) {
            word[i++] = tolower(c);
        } else if (i &gt; 0) {
            break;
        }
        (*index)++;
    }

    word[i] = '\0';
    while (paragraph[*index] &amp;&amp; !isalpha(paragraph[*index])) {
        (*index)++;
    }

    return word[0] ? word : NULL;
}

char* mostCommonWord(char* paragraph, char** banned, int bannedSize) {
    HashTableEntry hashTable[MAX_PARA_LEN] = {0};
    int index = 0;
    int maxCount = 0;
    char* mostCommon = NULL;

    while (paragraph[index]) {
        char* word = nextWord(paragraph, &amp;index);
        if (!word || isBanned(word, banned, bannedSize)) {
            continue;
        }

        int found = 0;
        for (int i = 0; i &lt; MAX_PARA_LEN &amp;&amp; hashTable[i].word[0]; i++) {
            if (strcmp(hashTable[i].word, word) == 0) {
                hashTable[i].count++;
                found = 1;
                if (hashTable[i].count &gt; maxCount) {
                    maxCount = hashTable[i].count;
                    mostCommon = hashTable[i].word;
                }
                break;
            }
        }

        if (!found) {
            for (int i = 0; i &lt; MAX_PARA_LEN; i++) {
                if (hashTable[i].word[0] == '\0') {
                    strcpy(hashTable[i].word, word);
                    hashTable[i].count = 1;
                    if (hashTable[i].count &gt; maxCount) {
                        maxCount = 1;
                        mostCommon = hashTable[i].word;
                    }
                    break;
                }
            }
        }
    }

    return mostCommon;
}</code></pre>
<h3 id="mcetoc_1i5eoag1i13">解释</h3>
<ol>
<li><strong>字符串转换为小写</strong>：在处理段落时，所有单词都会被转换为小写，以确保比较时不区分大小写。</li>
<li><strong>提取单词</strong>：使用 <code>nextWord</code> 函数从段落中依次提取单词，并跳过标点符号和空格。</li>
<li><strong>检查禁用词</strong>：每个提取的单词都会与禁用词列表进行比较，如果是禁用词则跳过。</li>
<li><strong>计数与哈希表</strong>：通过哈希表存储每个单词及其出现次数，并更新频率最高的非禁用词。</li>
<li><strong>返回结果</strong>：最终返回频率最高的非禁用词。</li>
</ol>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>1295. 统计位数为偶数的数字</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/1295-tong-ji-wei-shu-wei-ou-shu-de-shu-zi.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/1295-tong-ji-wei-shu-wei-ou-shu-de-shu-zi.html</id>
            <category term="力扣"/>

        <updated>2024-08-16T07:54:58+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <h3>题目</h3>
<p>给你一个整数数组 <code>nums</code>，请你返回其中位数为 <strong>偶数</strong> 的数字的个数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [12,345,2,6,7896]
<strong>输出：</strong>2
<strong>解释：
</strong>12 是 2 位数字（位数为偶数） 
345 是 3 位数字（位数为奇数）  
2 是 1 位数字（位数为奇数） 
6 是 1 位数字 位数为奇数） 
7896 是 4 位数字（位数为偶数）  
因此只有 12 和 7896 是位数为偶数的数字
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [555,901,482,1771]
<strong>输出：</strong>1 
<strong>解释： </strong>
只有 1771 是位数为偶数的数字。</pre>
<h3>代码</h3>
<pre class="language-c line-numbers"><code>int findNumbers(int* nums, int numsSize) {
    int count = 0;
    for (int i = 0; i &lt; numsSize; i++) {
        int k = 0;
        for (int j = nums[i]; j != 0; k++) {
            j = j / 10;
        }
        if (k % 2 == 0) {
            count++;
        }
    }
    return count;
}</code></pre>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>2525. 根据规则将箱子分类</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/2525-gen-ju-gui-ze-jiang-xiang-zi-fen-lei.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/2525-gen-ju-gui-ze-jiang-xiang-zi-fen-lei.html</id>
            <category term="力扣"/>

        <updated>2024-08-15T07:43:20+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i59kcaatr">题目</a></li>
<li><a href="#mcetoc_1i59kcaats">代码</a></li>
<li><a href="#mcetoc_1i59kcaatt">解释</a></li>
</ul>
</div>
<h3 id="mcetoc_1i59kcaatr">题目</h3>
<p>给你四个整数 <code>length</code> ，<code>width</code> ，<code>height</code> 和 <code>mass</code> ，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 <strong>类别</strong> 的字符串。</p>
<ul>
<li>如果满足以下条件，那么箱子是 <code>"Bulky"</code> 的：
<ul>
<li>箱子 <strong>至少有一个</strong> 维度大于等于 <code>10<sup>4</sup></code> 。</li>
<li>或者箱子的 <strong>体积</strong> 大于等于 <code>10<sup>9</sup></code> 。</li>
</ul>
</li>
<li>如果箱子的质量大于等于 <code>100</code> ，那么箱子是 <code>"Heavy"</code> 的。</li>
<li>如果箱子同时是 <code>"Bulky"</code> 和 <code>"Heavy"</code> ，那么返回类别为 <code>"Both"</code> 。</li>
<li>如果箱子既不是 <code>"Bulky"</code> ，也不是 <code>"Heavy"</code> ，那么返回类别为 <code>"Neither"</code> 。</li>
<li>如果箱子是 <code>"Bulky"</code> 但不是 <code>"Heavy"</code> ，那么返回类别为 <code>"Bulky"</code> 。</li>
<li>如果箱子是 <code>"Heavy"</code> 但不是 <code>"Bulky"</code> ，那么返回类别为 <code>"Heavy"</code> 。</li>
</ul>
<p><strong>注意</strong>，箱子的体积等于箱子的长度、宽度和高度的乘积。</p>
<h3 id="mcetoc_1i59kcaats">代码</h3>
<pre class="language-c line-numbers"><code>char* categorizeBox(int length, int width, int height, int mass) {
    long long volume = (long long)length * width * height;
    int isBulky = length &gt;= 10000 || width &gt;= 10000 || height &gt;= 10000 || volume &gt;= 1000000000;
    int isHeavy = mass &gt;= 100;

    if (isBulky &amp;&amp; isHeavy) {
        return "Both";
    } else if (isBulky) {
        return "Bulky";
    } else if (isHeavy) {
        return "Heavy";
    } else {
        return "Neither";
    }
}</code></pre>
<h3 id="mcetoc_1i59kcaatt">解释</h3>
<ol>
<li>计算体积 <code>volume</code>。</li>
<li>检查是否为“Bulky”：如果任一维度大于等于 10,000 或者体积大于等于 10^9，则标记为 Bulky。</li>
<li>检查是否为“Heavy”：如果质量大于等于 100，则标记为 Heavy。</li>
<li>根据条件返回相应的类别：<code>Both</code>、<code>Bulky</code>、<code>Heavy</code> 或 <code>Neither</code>。</li>
</ol>
            ]]>
        </content>
    </entry>
    <entry>
        <title>1880. 检查某单词是否等于两单词之和</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/1880-jian-cha-mou-dan-ci-shi-fou-deng-yu-liang-dan-ci-zhi-he.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/1880-jian-cha-mou-dan-ci-shi-fou-deng-yu-liang-dan-ci-zhi-he.html</id>
            <category term="力扣"/>

        <updated>2024-08-14T07:56:56+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i572omh714">题目</a></li>
<li><a href="#mcetoc_1i572omh715">代码</a></li>
<li><a href="#mcetoc_1i572omh716">解释</a></li>
</ul>
</div>
<h3 id="mcetoc_1i572omh714">题目</h3>
<p>字母的 <strong>字母值</strong> 取决于字母在字母表中的位置，<strong>从 0 开始</strong> 计数。即，<code>'a' -&gt; 0</code>、<code>'b' -&gt; 1</code>、<code>'c' -&gt; 2</code>，以此类推。</p>
<p>对某个由小写字母组成的字符串 <code>s</code> 而言，其 <strong>数值</strong> 就等于将 <code>s</code> 中每个字母的 <strong>字母值</strong> 按顺序 <strong>连接</strong> 并 <strong>转换</strong> 成对应整数。</p>
<ul>
<li>例如，<code>s = "acb"</code> ，依次连接每个字母的字母值可以得到 <code>"021"</code> ，转换为整数得到 <code>21</code> 。</li>
</ul>
<p>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成。</p>
<p>如果 <code>firstWord</code><em> </em>和<em> </em><code>secondWord</code> 的 <strong>数值之和</strong> 等于<em> </em><code>targetWord</code><em> </em>的数值，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>firstWord = "acb", secondWord = "cba", targetWord = "cdb"
<strong>输出：</strong>true
<strong>解释：</strong>
firstWord 的数值为 "acb" -&gt; "021" -&gt; 21
secondWord 的数值为 "cba" -&gt; "210" -&gt; 210
targetWord 的数值为 "cdb" -&gt; "231" -&gt; 231
由于 21 + 210 == 231 ，返回 true
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>firstWord = "aaa", secondWord = "a", targetWord = "aab"
<strong>输出：</strong>false
<strong>解释：</strong>
firstWord 的数值为 "aaa" -&gt; "000" -&gt; 0
secondWord 的数值为 "a" -&gt; "0" -&gt; 0
targetWord 的数值为 "aab" -&gt; "001" -&gt; 1
由于 0 + 0 != 1 ，返回 false</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>firstWord = "aaa", secondWord = "a", targetWord = "aaaa"
<strong>输出：</strong>true
<strong>解释：</strong>
firstWord 的数值为 "aaa" -&gt; "000" -&gt; 0
secondWord 的数值为 "a" -&gt; "0" -&gt; 0
targetWord 的数值为 "aaaa" -&gt; "0000" -&gt; 0
由于 0 + 0 == 0 ，返回 true</pre>
<h3 id="mcetoc_1i572omh715">代码</h3>
<pre class="language-c line-numbers"><code>int wordToNumber(char* word) {
    int number = 0;
    while (*word) {
        number = number * 10 + (*word - 'a');
        word++;
    }
    return number;
}

bool isSumEqual(char* firstWord, char* secondWord, char* targetWord) {
    // 将 firstWord 和 secondWord 转换为数值
    int firstValue = wordToNumber(firstWord);
    int secondValue = wordToNumber(secondWord);
    int targetValue = wordToNumber(targetWord);
    
    // 检查它们的数值之和是否等于 targetWord 的数值
    return (firstValue + secondValue == targetValue);
}</code></pre>
<h3 id="mcetoc_1i572omh716">解释</h3>
<ul>
<li>
<p><strong><code>wordToNumber</code> 函数</strong>: 使用 <code>(*word - 'a')</code> 计算字母的字母值。例如，<code>'a'</code> 的 ASCII 值是 97，所以 <code>'a' - 'a'</code> 结果为 <code>0</code>，而 <code>'b' - 'a'</code> 结果为 <code>1</code>，以此类推。</p>
</li>
<li>
<p><strong>主逻辑</strong>: 将 <code>firstWord</code> 和 <code>secondWord</code> 转换为数值并相加，然后与 <code>targetWord</code> 的数值进行比较。</p>
</li>
</ul>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>LCP 51. 烹饪料理</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/lcp-51-peng-ren-liao-li.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/lcp-51-peng-ren-liao-li.html</id>
            <category term="力扣"/>

        <updated>2024-08-13T07:47:41+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i54fqr0a3m">题目</a></li>
<li><a href="#mcetoc_1i54fqr0a3n">代码</a></li>
<li><a href="#mcetoc_1i54fqr0a3o">解释</a>
<ul>
<li><a href="#mcetoc_1i54fqr0a3p">关键思路</a></li>
<li><a href="#mcetoc_1i54fqr0a3q">具体流程</a></li>
<li><a href="#mcetoc_1i54fqr0a3r">为什么不用动态规划？</a></li>
</ul>
</li>
</ul>
</div>
<h3 id="mcetoc_1i54fqr0a3m">题目</h3>
<p>勇者背包内共有编号为 <code>0 ~ 4</code> 的五种食材，其中 <code>materials[j]</code> 表示第 <code>j</code> 种食材的数量。通过这些食材可以制作若干料理，<code>cookbooks[i][j]</code> 表示制作第 <code>i</code> 种料理需要第 <code>j</code> 种食材的数量，而 <code>attribute[i] = [x,y]</code> 表示第 <code>i</code> 道料理的美味度 <code>x</code> 和饱腹感 <code>y</code>。</p>
<p>在饱腹感不小于 <code>limit</code> 的情况下，请返回勇者可获得的最大美味度。如果无法满足饱腹感要求，则返回 <code>-1</code>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>每种料理只能制作一次。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>materials = [3,2,4,1,2]</code> <code>cookbooks = [[1,1,0,1,2],[2,1,4,0,0],[3,2,4,1,0]]</code> <code>attribute = [[3,2],[2,4],[7,6]]</code> <code>limit = 5</code></p>
<p>输出：<code>7</code></p>
<p>解释： 食材数量可以满足以下两种方案： 方案一：制作料理 0 和料理 1，可获得饱腹感 2+4、美味度 3+2 方案二：仅制作料理 2， 可饱腹感为 6、美味度为 7 因此在满足饱腹感的要求下，可获得最高美味度 7</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>materials = [10,10,10,10,10]</code> <code>cookbooks = [[1,1,1,1,1],[3,3,3,3,3],[10,10,10,10,10]]</code> <code>attribute = [[5,5],[6,6],[10,10]]</code> <code>limit = 1</code></p>
<p>输出：<code>11</code></p>
<p>解释：通过制作料理 0 和 1，可满足饱腹感，并获得最高美味度 11</p>
</blockquote>
<h3 id="mcetoc_1i54fqr0a3n">代码</h3>
<pre class="language-c line-numbers"><code>#include &lt;stdio.h&gt;

int max(int a, int b) {
    return a &gt; b ? a : b;
}

void dfs(int* materials, int materialsSize, int** cookbooks, int cookbooksSize, int** attribute, int limit, int index, int currentDelicious, int currentFullness, int* maxDelicious) {
    // 如果当前饱腹感已经大于等于 limit
    if (currentFullness &gt;= limit) {
        *maxDelicious = max(*maxDelicious, currentDelicious);
    }

    // 遍历每一种料理
    for (int i = index; i &lt; cookbooksSize; i++) {
        int canCook = 1;

        // 检查是否有足够的食材来制作这道料理
        for (int j = 0; j &lt; materialsSize; j++) {
            if (materials[j] &lt; cookbooks[i][j]) {
                canCook = 0;
                break;
            }
        }

        if (canCook) {
            // 做这道料理，更新材料剩余数量
            for (int j = 0; j &lt; materialsSize; j++) {
                materials[j] -= cookbooks[i][j];
            }

            // 递归调用，继续尝试制作下一道料理
            dfs(materials, materialsSize, cookbooks, cookbooksSize, attribute, limit, i + 1, currentDelicious + attribute[i][0], currentFullness + attribute[i][1], maxDelicious);

            // 回溯，恢复材料剩余数量
            for (int j = 0; j &lt; materialsSize; j++) {
                materials[j] += cookbooks[i][j];
            }
        }
    }
}

int perfectMenu(int* materials, int materialsSize, int** cookbooks, int cookbooksSize, int* cookbooksColSize, int** attribute, int attributeSize, int* attributeColSize, int limit) {
    int maxDelicious = -1;

    dfs(materials, materialsSize, cookbooks, cookbooksSize, attribute, limit, 0, 0, 0, &amp;maxDelicious);

    return maxDelicious;
}
</code></pre>
<h3 id="mcetoc_1i54fqr0a3o">解释</h3>
<p>这道题的核心在于如何选择一组料理，使得在满足饱腹感的前提下，获得最大的美味度。这实际上是一个经典的「0-1 背包问题」的变种，只不过背包的容量和价值都多维化了，因此不能直接使用动态规划来解决，而是使用深度优先搜索（DFS）进行组合的枚举。</p>
<h4 id="mcetoc_1i54fqr0a3p">关键思路</h4>
<ol>
<li>
<p><strong>深度优先搜索 (DFS)</strong>：DFS 是一种遍历或搜索树或图的算法。在这里，DFS 用来遍历所有可能的料理组合。通过递归的方法，我们从头到尾尝试每一种料理的组合。</p>
</li>
<li>
<p><strong>剪枝（提前停止不必要的计算）</strong>：在递归过程中，首先检查当前的食材是否足够制作某个料理。如果某个料理需要的食材超出了勇者的拥有量，我们就不再继续下去，这样可以减少无效的搜索。</p>
</li>
<li>
<p><strong>回溯</strong>：回溯是一种通过撤销某些选择来恢复原状的技术。在这道题中，当我们尝试制作某个料理时，会减少相应的食材数量；如果在接下来的搜索中发现这条路不合适，我们就会恢复食材的数量，然后尝试其他的组合。</p>
</li>
<li>
<p><strong>终止条件</strong>：当我们遍历完所有可能的料理组合后，检查当前组合的饱腹感是否满足要求，如果满足，就更新最大美味度。</p>
</li>
<li>
<p><strong>返回结果</strong>：最后，我们会返回遍历中找到的最大美味度值。如果遍历完所有组合后，没有任何一个组合能满足饱腹感要求，就返回 <code>-1</code>。</p>
</li>
</ol>
<h4 id="mcetoc_1i54fqr0a3q">具体流程</h4>
<p>假设你有 5 种食材，可以制作若干种料理，每种料理都有特定的美味度和饱腹感。目标是在至少达到某个饱腹感的前提下，最大化获得的美味度。</p>
<ul>
<li>
<p><strong>初始化</strong>：从第一个料理开始，初始的美味度和饱腹感为 <code>0</code>。</p>
</li>
<li>
<p><strong>递归搜索</strong>：对于每个料理，我们有两种选择：要么制作它，要么不制作它。如果制作它，就更新当前的美味度和饱腹感，并减少相应的食材数量；然后递归地进行下一道料理的选择。</p>
</li>
<li>
<p><strong>更新结果</strong>：每当发现一个新的组合能满足饱腹感要求时，比较其美味度是否超过当前已知的最大值。如果超过，则更新最大美味度。</p>
</li>
<li>
<p><strong>回溯</strong>：在返回上一层递归之前，恢复之前减少的食材数量，确保其他组合的尝试不会受到影响。</p>
</li>
</ul>
<h4 id="mcetoc_1i54fqr0a3r">为什么不用动态规划？</h4>
<p>动态规划通常用于处理「0-1 背包问题」，但这道题的复杂性在于：</p>
<ul>
<li>每种料理需要的食材种类不同，无法简单地用一个二维表来表示状态。</li>
<li>需要对每种料理的组合进行判断，处理多个维度（美味度和饱腹感）的问题。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>859. 亲密字符串</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/859-qin-mi-zi-fu-chuan.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/859-qin-mi-zi-fu-chuan.html</id>
            <category term="力扣"/>

        <updated>2024-08-12T07:53:59+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i51tpgc019">题目</a></li>
<li><a href="#mcetoc_1i51tpgc01a">代码</a></li>
<li><a href="#mcetoc_1i51tpgc01b">解释</a></li>
<li><a href="#mcetoc_1i51tpgc01c">复杂度</a></li>
</ul>
</div>
<h3 id="mcetoc_1i51tpgc019">题目</h3>
<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>
<ul>
<li>例如，在 <code>"abcd"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>"cbad"</code> 。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "ab", goal = "ba"
<strong>输出：</strong>true
<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 相等。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "ab", goal = "ab"
<strong>输出：</strong>false
<strong>解释：</strong>你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 不相等。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "aa", goal = "aa"
<strong>输出：</strong>true
<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 "aa"，此时 s 和 goal 相等。</pre>
<h3 id="mcetoc_1i51tpgc01a">代码</h3>
<pre class="language-c line-numbers"><code>bool buddyStrings(char * s, char * goal) {
    int len_s = strlen(s);
    int len_goal = strlen(goal);

    // 长度不同的情况
    if (len_s != len_goal) {
        return false;
    }

    // 如果字符串相同
    if (strcmp(s, goal) == 0) {
        // 检查是否有重复字符
        int count[26] = {0};
        for (int i = 0; i &lt; len_s; i++) {
            count[s[i] - 'a']++;
            if (count[s[i] - 'a'] &gt; 1) {
                return true;
            }
        }
        return false; // 没有重复字符，无法通过交换变为相同字符串
    } else {
        // 字符串不同的情况
        int first = -1, second = -1;
        for (int i = 0; i &lt; len_s; i++) {
            if (s[i] != goal[i]) {
                if (first == -1) {
                    first = i;
                } else if (second == -1) {
                    second = i;
                } else {
                    return false; // 超过两个字符不同
                }
            }
        }

        // 确保只有两个字符不同且交换后相等
        return (second != -1 &amp;&amp; s[first] == goal[second] &amp;&amp; s[second] == goal[first]);
    }
}</code></pre>
<h3 id="mcetoc_1i51tpgc01b">解释</h3>
<ol>
<li>
<p><strong>长度检查</strong>：</p>
<ul>
<li>如果 <code>s</code> 和 <code>goal</code> 的长度不同，直接返回 <code>false</code>，因为无法通过任何交换使它们相等。</li>
</ul>
</li>
<li>
<p><strong>相等的字符串</strong>：</p>
<ul>
<li>如果 <code>s</code> 和 <code>goal</code> 完全相等，我们检查 <code>s</code> 中是否有重复字符。</li>
<li>如果存在重复字符，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
<li>
<p><strong>不相等的字符串</strong>：</p>
<ul>
<li>我们需要找出 <code>s</code> 和 <code>goal</code> 中不同的两个字符的位置，并检查这两个字符是否可以通过交换使 <code>s</code> 和 <code>goal</code> 相等。</li>
<li>如果有两个不同的字符且交换后相等，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
</ol>
<h3 id="mcetoc_1i51tpgc01c">复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。我们只需要一次遍历来完成检查。</li>
<li><strong>空间复杂度</strong>：<code>O(1)</code>，仅使用了几个额外的变量用于计数和索引。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>551. 学生出勤记录 I</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/551-xue-sheng-chu-qin-ji-lu-i.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/551-xue-sheng-chu-qin-ji-lu-i.html</id>
            <category term="力扣"/>

        <updated>2024-08-11T08:03:28+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i4vbu31bv">题目</a></li>
<li><a href="#mcetoc_1i4vbu31b10">代码</a></li>
<li><a href="#mcetoc_1i4vbu31b11">代码解析</a></li>
<li><a href="#mcetoc_1i4vbu31b12">复杂度</a></li>
</ul>
</div>
<h3 id="mcetoc_1i4vbu31bv">题目</h3>
<p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<ul>
<li><code>'A'</code>：Absent，缺勤</li>
<li><code>'L'</code>：Late，迟到</li>
<li><code>'P'</code>：Present，到场</li>
</ul>
<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>
<ul>
<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>
<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>
</ul>
<p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "PPALLP"
<strong>输出：</strong>true
<strong>解释：</strong>学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "PPALLL"
<strong>输出：</strong>false
<strong>解释：</strong>学生最后三天连续迟到，所以不满足出勤奖励的条件。</pre>
<h3 id="mcetoc_1i4vbu31b10">代码</h3>
<pre class="language-c line-numbers"><code>bool checkRecord(char* s) {
    int countA = 0;       // 用来统计 'A' 的数量
    int consecutiveL = 0; // 用来统计连续 'L' 的数量

    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == 'A') {
            countA++;
            if (countA &gt;= 2) { // 如果 'A' 的数量达到 2，直接返回 false
                return false;
            }
        }

        if (s[i] == 'L') {
            consecutiveL++;
            if (consecutiveL &gt;=
                3) { // 如果连续 'L' 的数量达到 3，直接返回 false
                return false;
            }
        } else {
            consecutiveL = 0; // 如果当前字符不是 'L'，重置连续 'L' 计数
        }
    }

    return true; // 如果两个条件都未触发，则返回 true
}</code></pre>
<h3 id="mcetoc_1i4vbu31b11">代码解析</h3>
<ol>
<li>
<p><strong>计数缺勤天数 <code>countA</code></strong>：</p>
<ul>
<li>每次遇到字符 <code>'A'</code>，<code>countA</code> 自增。</li>
<li>如果 <code>countA</code> 达到或超过 2，说明缺勤天数不满足要求，直接返回 <code>false</code>。</li>
</ul>
</li>
<li>
<p><strong>统计连续迟到天数 <code>consecutiveL</code></strong>：</p>
<ul>
<li>每次遇到字符 <code>'L'</code>，<code>consecutiveL</code> 自增。</li>
<li>如果 <code>consecutiveL</code> 达到或超过 3，说明存在连续 3 天或以上的迟到，直接返回 <code>false</code>。</li>
<li>一旦遇到非 <code>'L'</code> 字符，<code>consecutiveL</code> 归零，重新开始统计。</li>
</ul>
</li>
<li>
<p><strong>返回结果</strong>：</p>
<ul>
<li>如果遍历结束后没有触发以上两个条件，则返回 <code>true</code>，表示可以获得出勤奖励。</li>
</ul>
</li>
</ol>
<h3 id="mcetoc_1i4vbu31b12">复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是字符串的长度。只需遍历字符串一次即可。</li>
<li><strong>空间复杂度</strong>：<code>O(1)</code>，只使用了几个固定大小的变量来记录状态。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>234. 回文链表</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/234-hui-wen-lian-biao.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/234-hui-wen-lian-biao.html</id>
            <category term="力扣"/>

        <updated>2024-08-11T07:51:41+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i4vbdq181">题目</a></li>
<li><a href="#mcetoc_1i4vb84nj2h">代码</a></li>
<li><a href="#mcetoc_1i4vb84nj2i">解释</a></li>
<li><a href="#mcetoc_1i4vb8mh82k">复杂度</a></li>
</ul>
</div>
<h3 id="mcetoc_1i4vbdq181">题目</h3>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为</p>
<div class="popover-wrapper inline-block" data-headlessui-state="">
<div>
<div id="headlessui-popover-button-:rah:" aria-expanded="false" data-headlessui-state="">
<div>回文链表</div>
</div>
<div> </div>
</div>
</div>
<p>。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="" data-is-external-image="true"></p>
<pre><strong>输入：</strong>head = [1,2,2,1]
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="" data-is-external-image="true"></p>
<pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>falsed</pre>
<h3 id="mcetoc_1i4vb84nj2h">代码</h3>
<pre class="language-c line-numbers"><code>struct ListNode* middle_find(struct ListNode* head) {
    struct ListNode* slow = head;
    struct ListNode* fast = head-&gt;next;

    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    return slow;
}

struct ListNode* reverse(struct ListNode* right_head) {
    struct ListNode* new_head = NULL;
    while (right_head != NULL) {
        struct ListNode* next = right_head-&gt;next;
        right_head-&gt;next = new_head;
        new_head = right_head;
        right_head = next;
    }
    return new_head;
}

bool isPalindrome(struct ListNode* head) {
    if (head == NULL) {
        return NULL;
    }

    struct ListNode* middle = middle_find(head);
    struct ListNode* right = reverse(middle-&gt;next);
    struct ListNode* right_copy = right;
    struct ListNode* tmp = head;

    while (tmp != NULL &amp;&amp; right_copy != NULL) {
        if (tmp-&gt;val != right_copy-&gt;val) {
            return false;
        }
        tmp = tmp-&gt;next;
        right_copy = right_copy-&gt;next;
    }

    middle-&gt;next = reverse(right);
    return true;
}</code></pre>
<h3 id="mcetoc_1i4vb84nj2i">解释</h3>
<ul>
<li>
<p><strong><code>middle_find</code> 函数</strong>:</p>
<ul>
<li>这个函数的目的是找到链表的中间节点。</li>
<li>使用了<strong>快慢指针</strong>技术：
<ul>
<li><code>slow</code> 指针每次移动一步。</li>
<li><code>fast</code> 指针每次移动两步。</li>
</ul>
</li>
<li>当 <code>fast</code> 指针到达链表的末尾时，<code>slow</code> 指针正好位于链表的中间。</li>
<li>返回的 <code>slow</code> 指针指向链表的中间节点。</li>
</ul>
</li>
<li>
<p><strong><code>reverse</code> 函数</strong>:</p>
<ul>
<li>这个函数的目的是反转从 <code>right_head</code> 开始的链表。</li>
<li>使用了三个指针来反转链表：
<ul>
<li><code>new_head</code> 用来指向反转后的链表的头部（最初为 <code>NULL</code>）。</li>
<li><code>right_head</code> 用来遍历链表，逐个反转节点。</li>
<li><code>next</code> 用来临时保存当前节点的下一个节点，以便在反转后继续遍历。</li>
</ul>
</li>
<li>函数返回反转后的链表头节点 <code>new_head</code>。</li>
</ul>
</li>
<li>
<p><strong><code>isPalindrome</code> 函数</strong>:</p>
<ul>
<li>这是主函数，用来判断给定链表是否为回文链表。</li>
<li>如果链表为空（即 <code>head</code> 为 <code>NULL</code>），直接返回 <code>NULL</code>（应返回 <code>false</code>，可能是个小错误）。</li>
<li>通过 <code>middle_find</code> 函数找到链表的中间节点。</li>
<li>反转中间节点后的右半部分链表，并将新头节点赋值给 <code>right</code>。</li>
<li>创建两个指针 <code>right_copy</code> 和 <code>tmp</code>，分别用于遍历反转后的右半部分链表和原始链表的左半部分。</li>
<li>通过遍历比较左半部分链表和右半部分反转链表的对应节点的值。</li>
<li>如果发现任何一对节点的值不相等，立即返回 <code>false</code>。</li>
<li>如果比较通过，链表是回文的，最后将反转的右半部分链表再次反转回来，恢复原链表的结构。</li>
</ul>
</li>
</ul>
<h3 id="mcetoc_1i4vb8mh82k">复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是链表的长度，因为我们只对链表进行了一次遍历和一次反转。</li>
<li><strong>空间复杂度</strong>：<code>O(1)</code>，除了几个指针变量外，没有使用额外的空间。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>20. 有效的括号</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/20-you-xiao-de-gua-hao.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/20-you-xiao-de-gua-hao.html</id>
            <category term="力扣"/>

        <updated>2024-08-11T07:12:12+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i4vbe4li3">题目</a></li>
<li><a href="#mcetoc_1i4v90abed">代码实现</a></li>
<li><a href="#mcetoc_1i4v90abee">代码解析</a></li>
<li><a href="#mcetoc_1i4v90abef">时间复杂度</a></li>
</ul>
</div>
<h3 id="mcetoc_1i4vbe4li3">题目</h3>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "()"
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "()[]{}"
<strong>输出：</strong>true
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "(]"
<strong>输出：</strong>false</pre>
<h3 id="mcetoc_1i4v90abed">代码实现</h3>
<pre class="language-c line-numbers"><code>bool isValid(char* s) {
    int n = strlen(s);
    // 如果字符串长度是奇数，直接返回 false
    if (n % 2 != 0) {
        return false;
    }

    // 用一个数组模拟栈
    char stack[n];
    int top = -1;

    for (int i = 0; i &lt; n; i++) {
        char c = s[i];
        if (c == '(' || c == '{' || c == '[') {
            // 将左括号压入栈中
            stack[++top] = c;
        } else {
            // 遇到右括号时，检查栈顶元素是否匹配
            if (top == -1) {
                return false;
            }
            char topChar = stack[top];
            if ((c == ')' &amp;&amp; topChar != '(') ||
                (c == '}' &amp;&amp; topChar != '{') ||
                (c == ']' &amp;&amp; topChar != '[')) {
                return false;
            }
            // 弹出栈顶元素
            top--;
        }
    }

    // 如果栈为空，所有括号都匹配
    return top == -1;
}</code></pre>
<h3 id="mcetoc_1i4v90abee">代码解析</h3>
<ol>
<li>
<p><strong>栈的模拟</strong>：我们用一个数组 <code>stack</code> 来模拟栈，并用 <code>top</code> 指针表示栈顶。</p>
<ul>
<li>当遇到左括号时，将其压入栈中。</li>
<li>当遇到右括号时，检查栈顶是否有匹配的左括号。</li>
<li>如果匹配，弹出栈顶的元素；否则返回 <code>false</code>。</li>
</ul>
</li>
<li>
<p><strong>字符串长度检查</strong>：如果字符串长度是奇数，则直接返回 <code>false</code>，因为不可能存在配对的括号。</p>
</li>
<li>
<p><strong>最终检查</strong>：在遍历完字符串后，检查栈是否为空。如果栈为空，说明所有的括号都成功匹配，否则返回 <code>false</code>。</p>
</li>
</ol>
<h3 id="mcetoc_1i4v90abef">时间复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>: 每个字符都要入栈或出栈，时间复杂度是 <code>O(n)</code>，其中 <code>n</code> 是字符串的长度。</li>
<li><strong>空间复杂度</strong>: 最坏情况下栈的大小为 <code>n/2</code>，因此空间复杂度也是 <code>O(n)</code>。</li>
</ul>
            ]]>
        </content>
    </entry>
</feed>
