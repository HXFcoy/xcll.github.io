<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>白衫如初</title>
    <link href="https://hxfcoy.github.io/xcll.github.io/feed.xml" rel="self" />
    <link href="https://hxfcoy.github.io/xcll.github.io" />
    <updated>2024-08-12T07:53:59+08:00</updated>
    <author>
        <name>fcoy</name>
    </author>
    <id>https://hxfcoy.github.io/xcll.github.io</id>

    <entry>
        <title>859. 亲密字符串</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/859-qin-mi-zi-fu-chuan.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/859-qin-mi-zi-fu-chuan.html</id>
            <category term="力扣"/>

        <updated>2024-08-12T07:53:59+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i51tpgc019">题目</a></li>
<li><a href="#mcetoc_1i51tpgc01a">代码</a></li>
<li><a href="#mcetoc_1i51tpgc01b">解释</a></li>
<li><a href="#mcetoc_1i51tpgc01c">复杂度</a></li>
</ul>
</div>
<h3 id="mcetoc_1i51tpgc019">题目</h3>
<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>
<ul>
<li>例如，在 <code>"abcd"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>"cbad"</code> 。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "ab", goal = "ba"
<strong>输出：</strong>true
<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 相等。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "ab", goal = "ab"
<strong>输出：</strong>false
<strong>解释：</strong>你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 不相等。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "aa", goal = "aa"
<strong>输出：</strong>true
<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 "aa"，此时 s 和 goal 相等。</pre>
<h3 id="mcetoc_1i51tpgc01a">代码</h3>
<pre class="language-c line-numbers"><code>bool buddyStrings(char * s, char * goal) {
    int len_s = strlen(s);
    int len_goal = strlen(goal);

    // 长度不同的情况
    if (len_s != len_goal) {
        return false;
    }

    // 如果字符串相同
    if (strcmp(s, goal) == 0) {
        // 检查是否有重复字符
        int count[26] = {0};
        for (int i = 0; i &lt; len_s; i++) {
            count[s[i] - 'a']++;
            if (count[s[i] - 'a'] &gt; 1) {
                return true;
            }
        }
        return false; // 没有重复字符，无法通过交换变为相同字符串
    } else {
        // 字符串不同的情况
        int first = -1, second = -1;
        for (int i = 0; i &lt; len_s; i++) {
            if (s[i] != goal[i]) {
                if (first == -1) {
                    first = i;
                } else if (second == -1) {
                    second = i;
                } else {
                    return false; // 超过两个字符不同
                }
            }
        }

        // 确保只有两个字符不同且交换后相等
        return (second != -1 &amp;&amp; s[first] == goal[second] &amp;&amp; s[second] == goal[first]);
    }
}</code></pre>
<h3 id="mcetoc_1i51tpgc01b">解释</h3>
<ol>
<li>
<p><strong>长度检查</strong>：</p>
<ul>
<li>如果 <code>s</code> 和 <code>goal</code> 的长度不同，直接返回 <code>false</code>，因为无法通过任何交换使它们相等。</li>
</ul>
</li>
<li>
<p><strong>相等的字符串</strong>：</p>
<ul>
<li>如果 <code>s</code> 和 <code>goal</code> 完全相等，我们检查 <code>s</code> 中是否有重复字符。</li>
<li>如果存在重复字符，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
<li>
<p><strong>不相等的字符串</strong>：</p>
<ul>
<li>我们需要找出 <code>s</code> 和 <code>goal</code> 中不同的两个字符的位置，并检查这两个字符是否可以通过交换使 <code>s</code> 和 <code>goal</code> 相等。</li>
<li>如果有两个不同的字符且交换后相等，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
</ol>
<h3 id="mcetoc_1i51tpgc01c">复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。我们只需要一次遍历来完成检查。</li>
<li><strong>空间复杂度</strong>：<code>O(1)</code>，仅使用了几个额外的变量用于计数和索引。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>551. 学生出勤记录 I</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/551-xue-sheng-chu-qin-ji-lu-i.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/551-xue-sheng-chu-qin-ji-lu-i.html</id>
            <category term="力扣"/>

        <updated>2024-08-11T08:03:28+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i4vbu31bv">题目</a></li>
<li><a href="#mcetoc_1i4vbu31b10">代码</a></li>
<li><a href="#mcetoc_1i4vbu31b11">代码解析</a></li>
<li><a href="#mcetoc_1i4vbu31b12">复杂度</a></li>
</ul>
</div>
<h3 id="mcetoc_1i4vbu31bv">题目</h3>
<p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<ul>
<li><code>'A'</code>：Absent，缺勤</li>
<li><code>'L'</code>：Late，迟到</li>
<li><code>'P'</code>：Present，到场</li>
</ul>
<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>
<ul>
<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>
<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>
</ul>
<p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "PPALLP"
<strong>输出：</strong>true
<strong>解释：</strong>学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "PPALLL"
<strong>输出：</strong>false
<strong>解释：</strong>学生最后三天连续迟到，所以不满足出勤奖励的条件。</pre>
<h3 id="mcetoc_1i4vbu31b10">代码</h3>
<pre class="language-c line-numbers"><code>bool checkRecord(char* s) {
    int countA = 0;       // 用来统计 'A' 的数量
    int consecutiveL = 0; // 用来统计连续 'L' 的数量

    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == 'A') {
            countA++;
            if (countA &gt;= 2) { // 如果 'A' 的数量达到 2，直接返回 false
                return false;
            }
        }

        if (s[i] == 'L') {
            consecutiveL++;
            if (consecutiveL &gt;=
                3) { // 如果连续 'L' 的数量达到 3，直接返回 false
                return false;
            }
        } else {
            consecutiveL = 0; // 如果当前字符不是 'L'，重置连续 'L' 计数
        }
    }

    return true; // 如果两个条件都未触发，则返回 true
}</code></pre>
<h3 id="mcetoc_1i4vbu31b11">代码解析</h3>
<ol>
<li>
<p><strong>计数缺勤天数 <code>countA</code></strong>：</p>
<ul>
<li>每次遇到字符 <code>'A'</code>，<code>countA</code> 自增。</li>
<li>如果 <code>countA</code> 达到或超过 2，说明缺勤天数不满足要求，直接返回 <code>false</code>。</li>
</ul>
</li>
<li>
<p><strong>统计连续迟到天数 <code>consecutiveL</code></strong>：</p>
<ul>
<li>每次遇到字符 <code>'L'</code>，<code>consecutiveL</code> 自增。</li>
<li>如果 <code>consecutiveL</code> 达到或超过 3，说明存在连续 3 天或以上的迟到，直接返回 <code>false</code>。</li>
<li>一旦遇到非 <code>'L'</code> 字符，<code>consecutiveL</code> 归零，重新开始统计。</li>
</ul>
</li>
<li>
<p><strong>返回结果</strong>：</p>
<ul>
<li>如果遍历结束后没有触发以上两个条件，则返回 <code>true</code>，表示可以获得出勤奖励。</li>
</ul>
</li>
</ol>
<h3 id="mcetoc_1i4vbu31b12">复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是字符串的长度。只需遍历字符串一次即可。</li>
<li><strong>空间复杂度</strong>：<code>O(1)</code>，只使用了几个固定大小的变量来记录状态。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>234. 回文链表</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/234-hui-wen-lian-biao.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/234-hui-wen-lian-biao.html</id>
            <category term="力扣"/>

        <updated>2024-08-11T07:51:41+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i4vbdq181">题目</a></li>
<li><a href="#mcetoc_1i4vb84nj2h">代码</a></li>
<li><a href="#mcetoc_1i4vb84nj2i">解释</a></li>
<li><a href="#mcetoc_1i4vb8mh82k">复杂度</a></li>
</ul>
</div>
<h3 id="mcetoc_1i4vbdq181">题目</h3>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为</p>
<div class="popover-wrapper inline-block" data-headlessui-state="">
<div>
<div id="headlessui-popover-button-:rah:" aria-expanded="false" data-headlessui-state="">
<div>回文链表</div>
</div>
<div> </div>
</div>
</div>
<p>。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="" data-is-external-image="true"></p>
<pre><strong>输入：</strong>head = [1,2,2,1]
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<p><img loading="lazy" src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="" data-is-external-image="true"></p>
<pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>falsed</pre>
<h3 id="mcetoc_1i4vb84nj2h">代码</h3>
<pre class="language-c line-numbers"><code>struct ListNode* middle_find(struct ListNode* head) {
    struct ListNode* slow = head;
    struct ListNode* fast = head-&gt;next;

    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    return slow;
}

struct ListNode* reverse(struct ListNode* right_head) {
    struct ListNode* new_head = NULL;
    while (right_head != NULL) {
        struct ListNode* next = right_head-&gt;next;
        right_head-&gt;next = new_head;
        new_head = right_head;
        right_head = next;
    }
    return new_head;
}

bool isPalindrome(struct ListNode* head) {
    if (head == NULL) {
        return NULL;
    }

    struct ListNode* middle = middle_find(head);
    struct ListNode* right = reverse(middle-&gt;next);
    struct ListNode* right_copy = right;
    struct ListNode* tmp = head;

    while (tmp != NULL &amp;&amp; right_copy != NULL) {
        if (tmp-&gt;val != right_copy-&gt;val) {
            return false;
        }
        tmp = tmp-&gt;next;
        right_copy = right_copy-&gt;next;
    }

    middle-&gt;next = reverse(right);
    return true;
}</code></pre>
<h3 id="mcetoc_1i4vb84nj2i">解释</h3>
<ul>
<li>
<p><strong><code>middle_find</code> 函数</strong>:</p>
<ul>
<li>这个函数的目的是找到链表的中间节点。</li>
<li>使用了<strong>快慢指针</strong>技术：
<ul>
<li><code>slow</code> 指针每次移动一步。</li>
<li><code>fast</code> 指针每次移动两步。</li>
</ul>
</li>
<li>当 <code>fast</code> 指针到达链表的末尾时，<code>slow</code> 指针正好位于链表的中间。</li>
<li>返回的 <code>slow</code> 指针指向链表的中间节点。</li>
</ul>
</li>
<li>
<p><strong><code>reverse</code> 函数</strong>:</p>
<ul>
<li>这个函数的目的是反转从 <code>right_head</code> 开始的链表。</li>
<li>使用了三个指针来反转链表：
<ul>
<li><code>new_head</code> 用来指向反转后的链表的头部（最初为 <code>NULL</code>）。</li>
<li><code>right_head</code> 用来遍历链表，逐个反转节点。</li>
<li><code>next</code> 用来临时保存当前节点的下一个节点，以便在反转后继续遍历。</li>
</ul>
</li>
<li>函数返回反转后的链表头节点 <code>new_head</code>。</li>
</ul>
</li>
<li>
<p><strong><code>isPalindrome</code> 函数</strong>:</p>
<ul>
<li>这是主函数，用来判断给定链表是否为回文链表。</li>
<li>如果链表为空（即 <code>head</code> 为 <code>NULL</code>），直接返回 <code>NULL</code>（应返回 <code>false</code>，可能是个小错误）。</li>
<li>通过 <code>middle_find</code> 函数找到链表的中间节点。</li>
<li>反转中间节点后的右半部分链表，并将新头节点赋值给 <code>right</code>。</li>
<li>创建两个指针 <code>right_copy</code> 和 <code>tmp</code>，分别用于遍历反转后的右半部分链表和原始链表的左半部分。</li>
<li>通过遍历比较左半部分链表和右半部分反转链表的对应节点的值。</li>
<li>如果发现任何一对节点的值不相等，立即返回 <code>false</code>。</li>
<li>如果比较通过，链表是回文的，最后将反转的右半部分链表再次反转回来，恢复原链表的结构。</li>
</ul>
</li>
</ul>
<h3 id="mcetoc_1i4vb8mh82k">复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是链表的长度，因为我们只对链表进行了一次遍历和一次反转。</li>
<li><strong>空间复杂度</strong>：<code>O(1)</code>，除了几个指针变量外，没有使用额外的空间。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>20. 有效的括号</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/20-you-xiao-de-gua-hao.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/20-you-xiao-de-gua-hao.html</id>
            <category term="力扣"/>

        <updated>2024-08-11T07:12:12+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i4vbe4li3">题目</a></li>
<li><a href="#mcetoc_1i4v90abed">代码实现</a></li>
<li><a href="#mcetoc_1i4v90abee">代码解析</a></li>
<li><a href="#mcetoc_1i4v90abef">时间复杂度</a></li>
</ul>
</div>
<h3 id="mcetoc_1i4vbe4li3">题目</h3>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "()"
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "()[]{}"
<strong>输出：</strong>true
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "(]"
<strong>输出：</strong>false</pre>
<h3 id="mcetoc_1i4v90abed">代码实现</h3>
<pre class="language-c line-numbers"><code>bool isValid(char* s) {
    int n = strlen(s);
    // 如果字符串长度是奇数，直接返回 false
    if (n % 2 != 0) {
        return false;
    }

    // 用一个数组模拟栈
    char stack[n];
    int top = -1;

    for (int i = 0; i &lt; n; i++) {
        char c = s[i];
        if (c == '(' || c == '{' || c == '[') {
            // 将左括号压入栈中
            stack[++top] = c;
        } else {
            // 遇到右括号时，检查栈顶元素是否匹配
            if (top == -1) {
                return false;
            }
            char topChar = stack[top];
            if ((c == ')' &amp;&amp; topChar != '(') ||
                (c == '}' &amp;&amp; topChar != '{') ||
                (c == ']' &amp;&amp; topChar != '[')) {
                return false;
            }
            // 弹出栈顶元素
            top--;
        }
    }

    // 如果栈为空，所有括号都匹配
    return top == -1;
}</code></pre>
<h3 id="mcetoc_1i4v90abee">代码解析</h3>
<ol>
<li>
<p><strong>栈的模拟</strong>：我们用一个数组 <code>stack</code> 来模拟栈，并用 <code>top</code> 指针表示栈顶。</p>
<ul>
<li>当遇到左括号时，将其压入栈中。</li>
<li>当遇到右括号时，检查栈顶是否有匹配的左括号。</li>
<li>如果匹配，弹出栈顶的元素；否则返回 <code>false</code>。</li>
</ul>
</li>
<li>
<p><strong>字符串长度检查</strong>：如果字符串长度是奇数，则直接返回 <code>false</code>，因为不可能存在配对的括号。</p>
</li>
<li>
<p><strong>最终检查</strong>：在遍历完字符串后，检查栈是否为空。如果栈为空，说明所有的括号都成功匹配，否则返回 <code>false</code>。</p>
</li>
</ol>
<h3 id="mcetoc_1i4v90abef">时间复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>: 每个字符都要入栈或出栈，时间复杂度是 <code>O(n)</code>，其中 <code>n</code> 是字符串的长度。</li>
<li><strong>空间复杂度</strong>: 最坏情况下栈的大小为 <code>n/2</code>，因此空间复杂度也是 <code>O(n)</code>。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>15. 三数之和</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/15-san-shu-zhi-he.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/15-san-shu-zhi-he.html</id>
            <category term="力扣"/>

        <updated>2024-08-10T21:38:37+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <div class="post__toc">
<h3>目录</h3>
<ul>
<li><a href="#mcetoc_1i4u8qoul21">实现代码</a></li>
<li><a href="#mcetoc_1i4u8jjga1r">解释</a>
<ul>
<li><a href="#mcetoc_1i4u8jjga1s">时间复杂度</a></li>
<li><a href="#mcetoc_1i4u8jjga1t">空间复杂度</a></li>
</ul>
</li>
<li><a href="#mcetoc_1i4u8jjga1u">cmp解释</a>
<ul>
<li><a href="#mcetoc_1i4u8jjga1v">返回值的含义</a></li>
</ul>
</li>
</ul>
</div>
<h3>题目</h3>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p> </p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [-1,0,1,2,-1,-4]
<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]
<strong>解释：</strong>
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [0,1,1]
<strong>输出：</strong>[]
<strong>解释：</strong>唯一可能的三元组和不为 0 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [0,0,0]
<strong>输出：</strong>[[0,0,0]]
<strong>解释：</strong>唯一可能的三元组和为 0 。</pre>
<h3 id="mcetoc_1i4u8qoul21">实现代码</h3>
<pre class="language-c line-numbers"><code>int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    int cmp(const void* a, const void* b) {
    return *(int*)a - *(int*)b;
}
    *returnSize = 0;
    if (numsSize &lt; 3) {
        return NULL;
    }

    // 先对数组排序
    qsort(nums, numsSize, sizeof(int), cmp);

    int** result = (int**)malloc(numsSize * numsSize * sizeof(int*));
    *returnColumnSizes = (int*)malloc(numsSize * numsSize * sizeof(int));

    for (int i = 0; i &lt; numsSize - 2; i++) {
        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
            continue; // 跳过重复的元素
        }

        int left = i + 1;
        int right = numsSize - 1;

        while (left &lt; right) {
            int sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {
                // 找到一组符合条件的三元组
                result[*returnSize] = (int*)malloc(3 * sizeof(int));
                result[*returnSize][0] = nums[i];
                result[*returnSize][1] = nums[left];
                result[*returnSize][2] = nums[right];
                (*returnColumnSizes)[*returnSize] = 3;
                (*returnSize)++;

                // 移动指针并跳过重复的元素
                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;
                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;

                left++;
                right--;
            } else if (sum &lt; 0) {
                left++;
            } else {
                right--;
            }
        }
    }

    return result;
}</code></pre>
<h3 id="mcetoc_1i4u8jjga1r">解释</h3>
<ol>
<li>
<p><strong>排序</strong>：我们首先对数组进行排序，这样可以更容易地避免重复的三元组，同时可以利用排序后的数组进行双指针的查找。</p>
</li>
<li>
<p><strong>双指针查找</strong>：</p>
<ul>
<li>固定一个数 <code>nums[i]</code>，然后使用双指针在 <code>nums[i+1]</code> 到 <code>nums[numsSize-1]</code> 之间寻找两个数使得三数之和为0。</li>
<li>如果找到满足条件的三元组，加入结果集，然后移动双指针，同时跳过重复的元素。</li>
</ul>
</li>
<li>
<p><strong>跳过重复</strong>：在外层循环和双指针循环中，如果发现当前元素与上一个元素相同，则跳过，避免重复三元组的出现。</p>
</li>
<li>
<p><strong>返回结果</strong>：</p>
<ul>
<li><code>returnSize</code>：表示返回的三元组的个数。</li>
<li><code>returnColumnSizes</code>：表示每个三元组的大小（都是3）。</li>
<li>返回的 <code>result</code> 是一个二维数组，包含所有符合条件的三元组。</li>
</ul>
</li>
</ol>
<h4 id="mcetoc_1i4u8jjga1s">时间复杂度</h4>
<ul>
<li><strong>排序</strong>的时间复杂度是 <code>O(n log n)</code>。</li>
<li>外层循环和内层双指针循环的复杂度是 <code>O(n^2)</code>。</li>
</ul>
<p>因此，整体的时间复杂度为 <code>O(n^2)</code>。</p>
<h4 id="mcetoc_1i4u8jjga1t">空间复杂度</h4>
<ul>
<li>主要用于存储结果的二维数组，最坏情况下需要 <code>O(n^2)</code> 的空间。</li>
</ul>
<h3 id="mcetoc_1i4u8jjga1u">cmp解释</h3>
<pre class="language-c line-numbers"><code>int cmp(const void* a, const void* b) {
    return *(int*)a - *(int*)b;
}</code></pre>
<ul>
<li>
<p><code>*(int*)a</code>：这个表达式首先将 <code>void*</code> 类型的指针 <code>a</code> 转换为 <code>int*</code> 类型的指针，然后通过 <code>*</code> 操作符解引用，获取该内存位置存储的整数值。</p>
</li>
<li>
<p><code>*(int*)b</code>：同样地，将 <code>void*</code> 类型的指针 <code>b</code> 转换为 <code>int*</code> 类型的指针，然后解引用获取整数值。</p>
</li>
<li>
<p><code>*(int*)a - *(int*)b</code>：通过相减，比较这两个整数的大小。</p>
</li>
</ul>
<h4 id="mcetoc_1i4u8jjga1v">返回值的含义</h4>
<ul>
<li>如果 <code>*(int*)a</code> 比 <code>*(int*)b</code> 小，则返回一个负数。这表示在排序过程中，<code>a</code> 应该排在 <code>b</code> 之前。</li>
<li>如果 <code>*(int*)a</code> 比 <code>*(int*)b</code> 大，则返回一个正数，表示 <code>a</code> 应该排在 <code>b</code> 之后。</li>
<li>如果 <code>*(int*)a</code> 和 <code>*(int*)b</code> 相等，则返回 0，表示它们在排序中的位置相同。</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>2582. 递枕头</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/2582-di-zhen-tou.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/2582-di-zhen-tou.html</id>
            <category term="力扣"/>

        <updated>2024-08-10T21:30:43+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p><code>n</code> 个人站成一排，按从 <code>1</code> 到 <code>n</code> 编号。最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。</p>
<ul>
<li>例如，当枕头到达第 <code>n</code> 个人时，TA 会将枕头传递给第 <code>n - 1</code> 个人，然后传递给第 <code>n - 2</code> 个人，依此类推。</li>
</ul>
<p>给你两个正整数 <code>n</code> 和 <code>time</code> ，返回 <code>time</code> 秒后拿着枕头的人的编号。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 4, time = 5
<strong>输出：</strong>2
<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 3 -&gt; 2 。
5 秒后，枕头传递到第 2 个人手中。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 3, time = 2
<strong>输出：</strong>3
<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 。
2 秒后，枕头传递到第 3 个人手中。</pre>
<pre class="language-c line-numbers"><code>int passThePillow(int n, int time) {
    // 如果time对(n-1)取模，则time % (n-1) 表示经过几个完整的正向传递后的余数
    // 通过方向(正向或反向)计算最终位置
    int cycle = time / (n - 1);
    int remainder = time % (n - 1);

    // 如果cycle是偶数，枕头在正向传递，位置为 1 + remainder
    // 如果cycle是奇数，枕头在反向传递，位置为 n - remainder
    if (cycle % 2 == 0) {
        return 1 + remainder;
    } else {
        return n - remainder;
    }
}</code></pre>
<ul>
<li>
<p><strong>循环次数</strong>：枕头传递方向的改变仅在到达队首或队尾时发生。如果将一个完整的往返（从第1个人传递到第n个人再回到第1个人）视为一个循环，枕头在经过一个完整的循环后又回到了初始位置。</p>
</li>
<li>
<p><strong>方向和位置计算</strong>：</p>
<ul>
<li>假设当前方向为正向（从第1个人向第n个人传递），则枕头每秒传递到下一个人。</li>
<li>一旦到达第n个人，方向就会反向，接下来每秒传递给前一个人。</li>
</ul>
</li>
<li>
<p><strong>计算逻辑</strong>：</p>
<ul>
<li>如果 <code>time</code> 的值加上初始位置是在第一个方向的范围内，则只需直接计算出具体位置。</li>
<li>如果在反方向范围内，也能通过简单的计算得到。</li>
</ul>
</li>
</ul>
            ]]>
        </content>
    </entry>
    <entry>
        <title>LCR 166. 珠宝的最高价值</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/lcr-166-zhu-bao-de-zui-gao-jie-zhi.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/lcr-166-zhu-bao-de-zui-gao-jie-zhi.html</id>
            <category term="力扣"/>

        <updated>2024-08-10T08:49:40+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>现有一个记作二维矩阵 <code>frame</code> 的珠宝架，其中 <code>frame[i][j]</code> 为该位置珠宝的价值。拿取珠宝的规则为：</p>
<ul>
<li>只能从架子的左上角开始拿珠宝</li>
<li>每次可以移动到右侧或下侧的相邻位置</li>
<li>到达珠宝架子的右下角时，停止拿取</li>
</ul>
<p>注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 <code>frame = [[0]]</code>。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> frame = [[1,3,1],[1,5,1],[4,2,1]]
<strong>输出:</strong> <code>12
</code><strong>解释:</strong> 路径 1→3→5→2→1 可以拿到最高价值的珠宝</pre>
<pre class="language-apacheconf line-numbers"><code>int jewelleryValue(int** frame, int frameSize, int* frameColSize) {
    if (frameSize == 0 || frameColSize[0] == 0) {
        return 0; // 处理空架子的情况
    }

    int dp[frameSize][frameColSize[0]];

    // 初始化 dp 数组
    dp[0][0] = frame[0][0];

    // 初始化第一列
    for (int i = 1; i &lt; frameSize; i++) {
        dp[i][0] = dp[i-1][0] + frame[i][0];
    }

    // 初始化第一行
    for (int j = 1; j &lt; frameColSize[0]; j++) {
        dp[0][j] = dp[0][j-1] + frame[0][j];
    }

    // 填充剩余的 dp 表格
    for (int i = 1; i &lt; frameSize; i++) {
        for (int j = 1; j &lt; frameColSize[0]; j++) {
            dp[i][j] = frame[i][j] + (dp[i-1][j] &gt; dp[i][j-1] ? dp[i-1][j] : dp[i][j-1]);
        }
    }

    // 返回右下角的最大值
    return dp[frameSize-1][frameColSize[0]-1];
}
</code></pre>
<h3>动态规划思想</h3>
<p>动态规划的核心思想是通过记录子问题的解来避免重复计算。我们用一个二维数组 <code>dp</code> 来存储从左上角到某个位置的最大珠宝总价值。</p>
<h4>1. <strong>定义状态</strong>：</h4>
<ul>
<li>设 <code>dp[i][j]</code> 表示从左上角 <code>(0, 0)</code> 到位置 <code>(i, j)</code> 的最大珠宝价值。</li>
</ul>
<h4>2. <strong>状态转移方程</strong>：</h4>
<ul>
<li>由于只能向右或向下移动，所以 <code>dp[i][j]</code> 可以从左侧的 <code>dp[i][j-1]</code> 或上方的 <code>dp[i-1][j]</code> 位置到达。因此，状态转移方程为： <img loading="lazy" src="file:///C:\Users\22501\AppData\Local\Temp\QQ_1723250937888.png" data-is-external-image="true">
<ul>
<li>这表示从 <code>(i-1, j)</code> 或 <code>(i, j-1)</code> 位置中选择一个较大的珠宝总价值，加上当前位置的珠宝价值 <code>frame[i][j]</code>，得到 <code>dp[i][j]</code> 的值。</li>
</ul>
</li>
</ul>
<h4>3. <strong>边界条件</strong>：</h4>
<ul>
<li><strong>第一行</strong>：只能从左边过来，所以 <code>dp[0][j]</code> 只能通过加上前一列的值得到： <img loading="lazy" src="file:///C:\Users\22501\AppData\Local\Temp\QQ_1723250945377.png" data-is-external-image="true"></li>
<li><strong>第一列</strong>：只能从上边过来，所以 <code>dp[i][0]</code> 只能通过加上前一行的值得到： <span class="katex-display"><span class="katex"><span class="katex-mathml">dp[i]<img loading="lazy" src="file:///C:\Users\22501\AppData\Local\Temp\QQ_1723250957613.png" data-is-external-image="true"></span></span></span></li>
<li><strong>起点</strong>：<code>dp[0][0]</code> 就是起点的珠宝价值 <code>frame[0][0]</code>。</li>
</ul>
<h4>4. <strong>求解最终结果</strong>：</h4>
<ul>
<li>当我们填满整个 <code>dp</code> 矩阵后，右下角的 <code>dp[m-1][n-1]</code> 就是从左上角到右下角的最大珠宝价值。</li>
</ul>
<h3>例子解析</h3>
<p>假设 <code>frame</code> 为：</p>
<table style="border-collapse: collapse; width: 40.7412%; height: 150.508px;" border="1">
<tbody>
<tr style="height: 50.1693px;">
<td style="width: 33.5074%; height: 50.1693px;">1</td>
<td style="width: 33.5074%; height: 50.1693px;">3</td>
<td style="width: 33.2234%; height: 50.1693px;">1</td>
</tr>
<tr style="height: 50.1693px;">
<td style="width: 33.5074%; height: 50.1693px;">1</td>
<td style="width: 33.5074%; height: 50.1693px;">5</td>
<td style="width: 33.2234%; height: 50.1693px;">1</td>
</tr>
<tr style="height: 50.1693px;">
<td style="width: 33.5074%; height: 50.1693px;">4</td>
<td style="width: 33.5074%; height: 50.1693px;">2</td>
<td style="width: 33.2234%; height: 50.1693px;">1</td>
</tr>
</tbody>
</table>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist-s">​​​</span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><strong>初始状态</strong>：
<ul>
<li><code>dp[0][0] = 1</code> （起点值为1）</li>
</ul>
</li>
<li><strong>第一行</strong>：
<ul>
<li><code>dp[0][1] = dp[0][0] + 3 = 4</code></li>
<li><code>dp[0][2] = dp[0][1] + 1 = 5</code></li>
</ul>
</li>
<li><strong>第一列</strong>：
<ul>
<li><code>dp[1][0] = dp[0][0] + 1 = 2</code></li>
<li><code>dp[2][0] = dp[1][0] + 4 = 6</code></li>
</ul>
</li>
<li><strong>填充剩余表格</strong>：
<ul>
<li><code>dp[1][1] = frame[1][1] + max(dp[0][1], dp[1][0]) = 5 + max(4, 2) = 9</code></li>
<li><code>dp[1][2] = frame[1][2] + max(dp[0][2], dp[1][1]) = 1 + max(5, 9) = 10</code></li>
<li><code>dp[2][1] = frame[2][1] + max(dp[1][1], dp[2][0]) = 2 + max(9, 6) = 11</code></li>
<li><code>dp[2][2] = frame[2][2] + max(dp[1][2], dp[2][1]) = 1 + max(10, 11) = 12</code></li>
</ul>
</li>
</ul>
<p>最终得到 <code>dp[2][2] = 12</code>，即从左上角到右下角路径上的最大珠宝价值是 12。</p>
<h3>总结</h3>
<p>通过这种方法，我们能有效计算出在给定规则下能拿到的最大珠宝价值，时间复杂度为 <code>O(m * n)</code>。</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>资源</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/ruan-jian.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/ruan-jian.html</id>

        <updated>2024-08-10T08:00:21+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>QQNT 插件加载器<a href="https://github.com/LiteLoaderQQNT/LiteLoaderQQNT">LiteLoaderQQNT</a></p>
<p>基于QQ的全自动签到模块<a href="https://github.com/LuckyPray/XAutoDaily">XAutoDaily</a></p>
<p>QQXposed 模块<a href="https://github.com/cinit/QAuxiliary">QAuxiliary</a></p>
<p><a href="https://github.com/clash-verge-rev/clash-verge-rev">clash-verge-rev</a></p>
<p>蔚蓝档案自动化<a href="https://github.com/pur1fying/blue_archive_auto_script">baas</a></p>
<p>Bili动态抽奖助手<a href="https://github.com/shanmiteko/LotteryAutoScript">LotteryAutoScript</a></p>
<p><a href="https://www.cycanime.com/">次元城动漫</a>（有弹幕，没啥广告，挺好用的）</p>
<p><a href="https://www.touchgal.co/">TouchGAL</a>-一站式Galgame文化社区！</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Steam游戏</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/steamyou-xi.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/steamyou-xi.html</id>
            <category term="游戏"/>

        <updated>2024-08-10T07:35:01+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p><a href="https://steamcommunity.com/profiles/76561199206989349/">我的steam😀</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>3. 无重复字符的最长子串</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan.html</id>
            <category term="力扣"/>

        <updated>2024-08-10T07:17:31+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 </strong><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">子串</span><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">的长度。</span></p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>s = "abcabcbb"
<strong>输出: </strong>3 
<strong>解释:</strong> 因为无重复字符的最长子串是 <code>"abc"</code>，所以其长度为 3。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入: </strong>s = "bbbbb"
<strong>输出: </strong>1
<strong>解释: </strong>因为无重复字符的最长子串是 <code>"b"</code>，所以其长度为 1。</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入: </strong>s = "pwwkew"
<strong>输出: </strong>3
<strong>解释: </strong>因为无重复字符的最长子串是 <code>"wke"</code>，所以其长度为 3。   请注意，你的答案必须是 <strong>子串 </strong>的长度，<code style="font-size: 0.790123em; font-weight: var(--font-weight-normal); font-family: var(--font-monospace); background-image: none;">"pwke"</code><span style="background-color: var(--gray-1); font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);"> 是一个</span><em style="font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);">子序列，</em><span style="background-color: var(--gray-1); font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);">不是子串。</span></pre>
<pre class="language-c line-numbers"><code>int lengthOfLongestSubstring(char* s) {
    int n = strlen(s);
    if (n == 0) return 0;
    
    int maxLength = 0;
    int start = 0;
    int charIndex[128];  // ASCII 字符总数为128
    
    // 初始化charIndex数组，-1表示未出现过
    for (int i = 0; i &lt; 128; i++) {
        charIndex[i] = -1;
    }
    
    for (int end = 0; end &lt; n; end++) {
        char currentChar = s[end];
        // 如果当前字符之前已经在窗口中出现过，移动start指针
        if (charIndex[currentChar] &gt;= start) {
            start = charIndex[currentChar] + 1;
        }
        
        // 更新字符的最新出现位置
        charIndex[currentChar] = end;
        
        // 更新最大长度
        int currentLength = end - start + 1;
        if (currentLength &gt; maxLength) {
            maxLength = currentLength;
        }
    }
    
    return maxLength;
}</code></pre>
            ]]>
        </content>
    </entry>
</feed>
