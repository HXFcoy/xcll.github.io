<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>白衫如初</title>
    <link href="https://hxfcoy.github.io/xcll.github.io/feed.xml" rel="self" />
    <link href="https://hxfcoy.github.io/xcll.github.io" />
    <updated>2024-08-10T18:34:11+08:00</updated>
    <author>
        <name>fcoy</name>
    </author>
    <id>https://hxfcoy.github.io/xcll.github.io</id>

    <entry>
        <title>LCR 166. 珠宝的最高价值</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/lcr-166-zhu-bao-de-zui-gao-jie-zhi.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/lcr-166-zhu-bao-de-zui-gao-jie-zhi.html</id>
            <category term="力扣"/>

        <updated>2024-08-10T08:49:40+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>现有一个记作二维矩阵 <code>frame</code> 的珠宝架，其中 <code>frame[i][j]</code> 为该位置珠宝的价值。拿取珠宝的规则为：</p>
<ul>
<li>只能从架子的左上角开始拿珠宝</li>
<li>每次可以移动到右侧或下侧的相邻位置</li>
<li>到达珠宝架子的右下角时，停止拿取</li>
</ul>
<p>注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 <code>frame = [[0]]</code>。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> frame = [[1,3,1],[1,5,1],[4,2,1]]
<strong>输出:</strong> <code>12
</code><strong>解释:</strong> 路径 1→3→5→2→1 可以拿到最高价值的珠宝</pre>
<pre class="language-apacheconf"><code>int jewelleryValue(int** frame, int frameSize, int* frameColSize) {
    if (frameSize == 0 || frameColSize[0] == 0) {
        return 0; // 处理空架子的情况
    }

    int dp[frameSize][frameColSize[0]];

    // 初始化 dp 数组
    dp[0][0] = frame[0][0];

    // 初始化第一列
    for (int i = 1; i &lt; frameSize; i++) {
        dp[i][0] = dp[i-1][0] + frame[i][0];
    }

    // 初始化第一行
    for (int j = 1; j &lt; frameColSize[0]; j++) {
        dp[0][j] = dp[0][j-1] + frame[0][j];
    }

    // 填充剩余的 dp 表格
    for (int i = 1; i &lt; frameSize; i++) {
        for (int j = 1; j &lt; frameColSize[0]; j++) {
            dp[i][j] = frame[i][j] + (dp[i-1][j] &gt; dp[i][j-1] ? dp[i-1][j] : dp[i][j-1]);
        }
    }

    // 返回右下角的最大值
    return dp[frameSize-1][frameColSize[0]-1];
}
</code></pre>
<h3>动态规划思想</h3>
<p>动态规划的核心思想是通过记录子问题的解来避免重复计算。我们用一个二维数组 <code>dp</code> 来存储从左上角到某个位置的最大珠宝总价值。</p>
<h4>1. <strong>定义状态</strong>：</h4>
<ul>
<li>设 <code>dp[i][j]</code> 表示从左上角 <code>(0, 0)</code> 到位置 <code>(i, j)</code> 的最大珠宝价值。</li>
</ul>
<h4>2. <strong>状态转移方程</strong>：</h4>
<ul>
<li>由于只能向右或向下移动，所以 <code>dp[i][j]</code> 可以从左侧的 <code>dp[i][j-1]</code> 或上方的 <code>dp[i-1][j]</code> 位置到达。因此，状态转移方程为： <img loading="lazy" src="file:///C:\Users\22501\AppData\Local\Temp\QQ_1723250937888.png" data-is-external-image="true">
<ul>
<li>这表示从 <code>(i-1, j)</code> 或 <code>(i, j-1)</code> 位置中选择一个较大的珠宝总价值，加上当前位置的珠宝价值 <code>frame[i][j]</code>，得到 <code>dp[i][j]</code> 的值。</li>
</ul>
</li>
</ul>
<h4>3. <strong>边界条件</strong>：</h4>
<ul>
<li><strong>第一行</strong>：只能从左边过来，所以 <code>dp[0][j]</code> 只能通过加上前一列的值得到： <img loading="lazy" src="file:///C:\Users\22501\AppData\Local\Temp\QQ_1723250945377.png" data-is-external-image="true"></li>
<li><strong>第一列</strong>：只能从上边过来，所以 <code>dp[i][0]</code> 只能通过加上前一行的值得到： <span class="katex-display"><span class="katex"><span class="katex-mathml">dp[i]<img loading="lazy" src="file:///C:\Users\22501\AppData\Local\Temp\QQ_1723250957613.png" data-is-external-image="true"></span></span></span></li>
<li><strong>起点</strong>：<code>dp[0][0]</code> 就是起点的珠宝价值 <code>frame[0][0]</code>。</li>
</ul>
<h4>4. <strong>求解最终结果</strong>：</h4>
<ul>
<li>当我们填满整个 <code>dp</code> 矩阵后，右下角的 <code>dp[m-1][n-1]</code> 就是从左上角到右下角的最大珠宝价值。</li>
</ul>
<h3>例子解析</h3>
<p>假设 <code>frame</code> 为：</p>
<table style="border-collapse: collapse; width: 40.7412%; height: 150.508px;" border="1">
<tbody>
<tr style="height: 50.1693px;">
<td style="width: 33.5074%; height: 50.1693px;">1</td>
<td style="width: 33.5074%; height: 50.1693px;">3</td>
<td style="width: 33.2234%; height: 50.1693px;">1</td>
</tr>
<tr style="height: 50.1693px;">
<td style="width: 33.5074%; height: 50.1693px;">1</td>
<td style="width: 33.5074%; height: 50.1693px;">5</td>
<td style="width: 33.2234%; height: 50.1693px;">1</td>
</tr>
<tr style="height: 50.1693px;">
<td style="width: 33.5074%; height: 50.1693px;">4</td>
<td style="width: 33.5074%; height: 50.1693px;">2</td>
<td style="width: 33.2234%; height: 50.1693px;">1</td>
</tr>
</tbody>
</table>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist-s">​​​</span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><strong>初始状态</strong>：
<ul>
<li><code>dp[0][0] = 1</code> （起点值为1）</li>
</ul>
</li>
<li><strong>第一行</strong>：
<ul>
<li><code>dp[0][1] = dp[0][0] + 3 = 4</code></li>
<li><code>dp[0][2] = dp[0][1] + 1 = 5</code></li>
</ul>
</li>
<li><strong>第一列</strong>：
<ul>
<li><code>dp[1][0] = dp[0][0] + 1 = 2</code></li>
<li><code>dp[2][0] = dp[1][0] + 4 = 6</code></li>
</ul>
</li>
<li><strong>填充剩余表格</strong>：
<ul>
<li><code>dp[1][1] = frame[1][1] + max(dp[0][1], dp[1][0]) = 5 + max(4, 2) = 9</code></li>
<li><code>dp[1][2] = frame[1][2] + max(dp[0][2], dp[1][1]) = 1 + max(5, 9) = 10</code></li>
<li><code>dp[2][1] = frame[2][1] + max(dp[1][1], dp[2][0]) = 2 + max(9, 6) = 11</code></li>
<li><code>dp[2][2] = frame[2][2] + max(dp[1][2], dp[2][1]) = 1 + max(10, 11) = 12</code></li>
</ul>
</li>
</ul>
<p>最终得到 <code>dp[2][2] = 12</code>，即从左上角到右下角路径上的最大珠宝价值是 12。</p>
<h3>总结</h3>
<p>通过这种方法，我们能有效计算出在给定规则下能拿到的最大珠宝价值，时间复杂度为 <code>O(m * n)</code>。</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>资源</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/ruan-jian.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/ruan-jian.html</id>

        <updated>2024-08-10T08:00:21+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>QQNT 插件加载器<a href="https://github.com/LiteLoaderQQNT/LiteLoaderQQNT">LiteLoaderQQNT</a></p>
<p>基于QQ的全自动签到模块<a href="https://github.com/LuckyPray/XAutoDaily">XAutoDaily</a></p>
<p>QQXposed 模块<a href="https://github.com/cinit/QAuxiliary">QAuxiliary</a></p>
<p><a href="https://github.com/clash-verge-rev/clash-verge-rev">clash-verge-rev</a></p>
<p>蔚蓝档案自动化<a href="https://github.com/pur1fying/blue_archive_auto_script">baas</a></p>
<p>Bili动态抽奖助手<a href="https://github.com/shanmiteko/LotteryAutoScript">LotteryAutoScript</a></p>
<p><a href="https://www.cycanime.com/">次元城动漫</a>（有弹幕，没啥广告，挺好用的）</p>
<p><a href="https://www.touchgal.co/">TouchGAL</a>-一站式Galgame文化社区！</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Steam游戏</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/steamyou-xi.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/steamyou-xi.html</id>
            <category term="游戏"/>

        <updated>2024-08-10T07:35:01+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p><a href="https://steamcommunity.com/profiles/76561199206989349/">我的steam😀</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>3. 无重复字符的最长子串</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan.html</id>
            <category term="力扣"/>

        <updated>2024-08-10T07:17:31+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 </strong><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">子串</span><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">的长度。</span></p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>s = "abcabcbb"
<strong>输出: </strong>3 
<strong>解释:</strong> 因为无重复字符的最长子串是 <code>"abc"</code>，所以其长度为 3。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入: </strong>s = "bbbbb"
<strong>输出: </strong>1
<strong>解释: </strong>因为无重复字符的最长子串是 <code>"b"</code>，所以其长度为 1。</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入: </strong>s = "pwwkew"
<strong>输出: </strong>3
<strong>解释: </strong>因为无重复字符的最长子串是 <code>"wke"</code>，所以其长度为 3。   请注意，你的答案必须是 <strong>子串 </strong>的长度，<code style="font-size: 0.790123em; font-weight: var(--font-weight-normal); font-family: var(--font-monospace); background-image: none;">"pwke"</code><span style="background-color: var(--gray-1); font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);"> 是一个</span><em style="font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);">子序列，</em><span style="background-color: var(--gray-1); font-size: 0.790123em; color: var(--text-primary-color); font-family: var(--editor-font-family); font-weight: var(--font-weight-normal);">不是子串。</span></pre>
<pre class="language-c"><code>int lengthOfLongestSubstring(char* s) {
    int n = strlen(s);
    if (n == 0) return 0;
    
    int maxLength = 0;
    int start = 0;
    int charIndex[128];  // ASCII 字符总数为128
    
    // 初始化charIndex数组，-1表示未出现过
    for (int i = 0; i &lt; 128; i++) {
        charIndex[i] = -1;
    }
    
    for (int end = 0; end &lt; n; end++) {
        char currentChar = s[end];
        // 如果当前字符之前已经在窗口中出现过，移动start指针
        if (charIndex[currentChar] &gt;= start) {
            start = charIndex[currentChar] + 1;
        }
        
        // 更新字符的最新出现位置
        charIndex[currentChar] = end;
        
        // 更新最大长度
        int currentLength = end - start + 1;
        if (currentLength &gt; maxLength) {
            maxLength = currentLength;
        }
    }
    
    return maxLength;
}</code></pre>
            ]]>
        </content>
    </entry>
    <entry>
        <title>2. 两数相加</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/2-liang-shu-xiang-jia.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/2-liang-shu-xiang-jia.html</id>
            <category term="力扣"/>

        <updated>2024-08-10T07:14:36+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p> </p>
<p><strong class="example">示例 1：</strong></p>
<p><img loading="lazy" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="" data-is-external-image="true"></p>
<pre><strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]
<strong>输出：</strong>[7,0,8]
<strong>解释：</strong>342 + 465 = 807.
</pre>
<p><strong class="example">示例 2：</strong></p>
<pre><strong>输入：</strong>l1 = [0], l2 = [0]
<strong>输出：</strong>[0]
</pre>
<p><strong class="example">示例 3：</strong></p>
<pre><strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
<strong>输出：</strong>[8,9,9,9,0,0,0,1]</pre>
<p> </p>
<pre class="language-c"><code>struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode dummy;
    dummy.next = NULL;
    struct ListNode* current = &amp;dummy;
    int carry = 0;

    // 遍历两个链表，直到所有的节点处理完毕
    while (l1 != NULL || l2 != NULL) {
        // 获取当前节点的值，如果当前链表结束则用0代替
        int val1 = (l1 != NULL) ? l1-&gt;val : 0;
        int val2 = (l2 != NULL) ? l2-&gt;val : 0;
        
        // 计算当前位的和以及进位
        int total = val1 + val2 + carry;
        carry = total / 10;
        int currentSum = total % 10;
        
        // 将计算的当前位加入结果链表
        current-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
        current-&gt;next-&gt;val = currentSum;
        current-&gt;next-&gt;next = NULL;
        current = current-&gt;next;
        
        // 移动指针
        if (l1 != NULL) l1 = l1-&gt;next;
        if (l2 != NULL) l2 = l2-&gt;next;
    }
    
    // 如果最后有进位，添加一个新的节点
    if (carry &gt; 0) {
        current-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
        current-&gt;next-&gt;val = carry;
        current-&gt;next-&gt;next = NULL;
    }
    
    // 返回结果链表的头结点
    return dummy.next;
}</code></pre>
            ]]>
        </content>
    </entry>
    <entry>
        <title>1. 两数之和</title>
        <author>
            <name>fcoy</name>
        </author>
        <link href="https://hxfcoy.github.io/xcll.github.io/1-liang-shu-zhi-he.html"/>
        <id>https://hxfcoy.github.io/xcll.github.io/1-liang-shu-zhi-he.html</id>
            <category term="力扣"/>

        <updated>2024-08-10T07:10:58+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p> </p>
<p><strong class="example">示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,7,11,15], target = 9
<strong>输出：</strong>[0,1]
<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</pre>
<p><strong class="example">示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [3,2,4], target = 6
<strong>输出：</strong>[1,2]
</pre>
<p><strong class="example">示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [3,3], target = 6
<strong>输出：</strong>[0,1]<code style="font-weight: var(--font-weight-normal);"></code><code></code></pre>
<pre class="language-c"><code>int* twoSum(int* nums, int numsSize, int target, int* returnSize) {

    // 用于存储结果的数组
    int *result = (int *)malloc(2 * sizeof(int));
    *returnSize = 2; // 结果数组的大小是2
    // 遍历数组，寻找和为target的两个数
    for (int i = 0; i &lt; numsSize; i++) {
        for (int j = i + 1; j &lt; numsSize; j++) {
            // 如果找到，返回它们的下标
            if (nums[i] + nums[j] == target) {
                result[0] = i;
                result[1] = j;
                return result;
            }
        }
    }
    // 如果未找到，返回NULL
    *returnSize = 0;
    return NULL;
}</code></pre>
            ]]>
        </content>
    </entry>
</feed>
